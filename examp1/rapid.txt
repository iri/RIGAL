  RIGAL RAPID PROGRAMMING GUIDE       (W.E. 26.10.90)
  =============================
 Some considerations on fast Rigal execution and about
some optimizations for recursive programs.
 Global algorithmic ideas :
If your algorithm is tree-building - try use such ideas :
1.Every tree node accords to one call of Rigal rule
2.Next node is recursive call result (from previous rule),
  may be through some other rules.
3. Node is element of big array (list) and node refers to others
by their "numbers of elements" in this array.
4. Tree (may be) not exist as data structure at execution
time. Tree represented by tree-like history of execution
of recursive rules."Good" nodes are accumulated in special list,
or (more fast to search) in special another tree with well-chosen
selectors. This way is good if tree building and tree traversing
may be done in one pass.
5. Prepare all possible trees and tables in form of array or tree
of arrays - before starting recursion. It helps to write
cycles on lists , not on trees.
6. Use #CALL_PAS(60-66) - fast trees and lists.

Local optimizations of programs.
-------------------------------
Don't use constructors in recursive called rule. It eats
both time and memory.
Operations in order of descending efficiency (from very slow to fast)
as it is in compiled Rigal program.

INEFFICIENT:
================
 SAVE; If SAVE is last statement in program -> it is implemented
       1 1/2 times faster.
 LOAD
 #EXPLODE - very inefficient
 #IMPLODE
 FORALL $A IN $B - if $B is tree
 <* $A : $B *>
 $A !! $B  - if $B is big list - elements copied one after one.
 $A ++ $B  - if $B is big
 $A ++ $B  - if $A is big
 $A:=<.D:E.>   - every tree or list takes minimum 40 bytes
 $A:=(. D E .)
 #A ( $B $C ) - if call any rule with 2 or more parameters
            ( this will be optimized in nearest future )

MIDDLE EFFICIENCY AND GOOD
==========================
 $A!.:=$K  - if $A is small
 $A.$D:=$K
 $A++:=<. A:B, C:D, F:E.>
 $A!!(. A B C .)
 Arithmetical expressions
 $A.$B, $A[$B]
 $A.ABC  $A[5]
 Patterns with constants.

IMPLEMENTED VERY GOOD (in Pascal level):
=======================================
 Clusters ( will be implemented in future )
 #CALL_PAS,#CHR, #ORD, predicates
 #LEN of tree or list
 #AA( $P1 $P2 $P3 $P4  ) - with one to four parameters
 FORALL $A IN $B - if $B is list
 $A+:=number
 $A !. $B
 IF/ELSE/FI, LOOP, BREAK , RETURN
 LAST #A $A
 $ $$
 $A:=$B;
 Single variable everywhere is of equal (or a
  little more) efficient as constant with the same value.

ON PAGING CONTROL
=================
We recommend to use new #CALL_PAS(42) to know count
of filled virtual memory pages in every N-th step
of algorithm.
Use #CALL_PAS(1) to require user to stop execution
in every N-th step.
If algorithm is iterative - use #CALL_PAS(45) to clean
memory

Every page is 8 KBytes.
Totally is 256 pages ( 2 MBytes )
In heap memory - no more than 50 pages,
in 1300 Kb virtual disk - 170 pages
in  300 Kb vitrual disk -  45 pages
in hard disk - all remainder.

One atom (or number) takes 8 bytes,
One list of length N takes N*5 bytes, minimum 40
One tree of length N takes N*10 bytes, minimum 40