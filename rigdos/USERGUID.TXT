                       University of Latvia
           Institute of Mathematcs and Computer Science




                     RIGAL PROGRAMMING SYSTEM

                     ========================


                    FOR IBM/PC/XT/AT IN MS-DOS


                        PROGRAMMER'S GUIDE



        TABLE OF CONTENTS
  ABSTRACT
  1. General information
  1.1 Introduction
  1.2 Notions of the integrated environment
  1.3 Files and file extensions
  1.4 About this guide
  1.5 How to contact the authors
  1.6 What is on your disks
  1.7 Configuration requirements
  1.8 Differences between version A and B
  1.9 How to install Rigal on your computer
  1.10 How to start up Rigal
  1.11 Editor menu and the hot keys
  1.12 How to create a simple program
  2. Additional features of the language
  2.1 Rigal lexical syntax
  2.2 Including other files
  2.3 Atom  types
  2.4   Lazy  boolean   evaluation
  2.5 Opening text files
  2.6 Text output
  2.7 Length of the text file line
  2.8 New  line format
  2.9 LOAD and  SAVE  statements
  2.10 PRINT statement
  2.11. Built-in rules
  2.12 Passing parameters to the program
  3. Features of the Integrated Environment
  3.1 Text editor
  3.1.1 Menu bar
  3.1.2 Hot keys
  3.1.3 Editor keys
  3.2 File manipulations
  3.3 Syntax checker
  3.4 The interpreter
  3.4.1 The interpreter in the integrated environment.
  3.4.2 The interpreter in the command line mode.
  3.4.3 Program execution by the interpreter
  3.5 Compiler
  3.5.1 Compilation phases
  3.5.2 How to start up a compiled program
  3.5.3 Execution of the compiled program
  3.6 Cross reference table
  3.7 Show saved Rigal object
  3.8 Type compatibility checker
  3.9 Status of the integrated environment
  4     The new lexical analyzer
  4.1 The simplest lexical utility
  4.2 Reading from file
  4.3 Reading from list of atoms
  4.4 Reading from random access memory
  4.5 Options
  4.6 Common components of the lexical grammars
  4.7 Using options
  4.8  Coordinate calculation
  4.9  Coordinate marks
  4.10   Structure control characters
  4.11  Lexical error messages
  4.12 Error message code numbers
  5  Scanners   and   special   subroutines
  6  Virtual memory
  APPENDIX A. Messages of the syntax checker
  APPENDIX B. Run time error messages
  APPENDIX C. Debugging messages
  APPENDIX D. Syntax grammar of Rigal
  APPENDIX E. Reference table on #CALL_PAS parameters



                             ABSTRACT

      The  Programming  system  for  Rigal  programm developement
consists  of  Rigal  integrated  environment  and several service
programs.  This document gives you comprehensive guidelines about
interaction with the programming system.


                      1. General information

                         1.1 Introduction

    Rigal  is  a  high  level  programming  language designed for
syntax analysis, program optimization, code generation, converter
writing  and  rapid  design  of  language  prototypes.  RIGAL  is
designed  in the Institute of Mathematics and Computer Science of
the  University  of  Latvia in 1987 - 1990. It was implemented in
RSX-11M,   VAX/VMS   and   MS-DOS   operating   systems.  Current
implementation  runs  on  IBM/PC/XT&AT  and compatible computers.
Implementation uses Borland's Turbo Pascal and Rigal itself.



             1.2 Notions of the integrated environment

     Rigal is implemented as a set of united components. We shall
call  this  union  Rigal integrated environment. It includes text
editor,  interpreter  and  compiler. Menus, windows, on line help
and utilities are supported.

    The implementation has two versions :

    Version A is simple and small. It is intended the beginners;

    Version  B  is  more  complicated.  It  is  intended for more
advanced users.

    The  editor  is  assigned  to  create, view and modify source
program  files.  Besides, it allows any ASCII file editing. Other
components  are called through pull down menus or functional keys
from the editor window.

    These components are the following:

    The  syntax  checker (Check) checks correctness of your Rigal
program and creates an intermediate code for interpretation.
    The  interpreter  (Run)  starts  up  the program. It uses the
intermediate  code.  The  interpreter  is  intended  for  program
debugging.
    The compiler (Compile) makes executable file of your program.
The  result  program runs fast. In both cases (interpretation and
running compiled program) results are the same.
     Utilities allow to browse or print out contents of saved (by
SAVE  statement) Rigal objects. The cross reference table and the
type compatibility checking utility are supported.


                   1.3 Files and file extensions

    File  names  consist  of  no  more than 8 symbols. Extensions
consist  of  no  more  than  3  symbols.  We  use  the  following
extensions :

   .EXE  -  executable file. The Rigal implementation consists of
such  files.  Rigal compiler makes such files from source program
text.

   .RIG - source text in Rigal. Other extensions are not allowed.

   .RSC  -  intermediate code for Rigal program. It is created by
the syntax checker and used by the interpreter.

    X*.PAS,  X*.TPU,  *.RS2,  *.RS4  -  used  by  the compiler as
intermediate  files. By default they are deleted when compilation
is completed.

   .TPL  - run time library. It consists of compiled Turbo Pascal
units necessary for the compiler.

    .PCK  and  .CFG  - files RIGAL.PCK and RIGAL.CFG contain some
information about the current state of the environment.

    Files  with extensions RSC, RS2, RS4, PCK, CFG, EXE, TPL, TPU
and all saved Rigal objects are not ASCII text files. They cannot
be processed by the text editor.


                       1.4 About this guide

    This  user's  guide will help you to type, debug, compile and
save your program. The diskettes contain simple examples. You can
investigate, execute and modify them.

    Before  starting  the  work  with Rigal you should know about
MS-DOS  operating system, running programs and manipulations with
files and directories.

    Pay  attention  to  the  version  number.  There  are version
compatibility  discussion  and  last  minute  notes in README.1ST
file.


                  1.5 How to contact the authors

    If  you  want to get some additional information or to inform
us about any problems with Rigal - please contact

    Mikhail  Auguston,  Institute  of  Mathematics  and  Computer
Science,  Latvia  University,  Rainis  blvd.  29,  Riga,  Latvia,
SU-226250.  Phone  (013-2)224363,  telex  161172  TEMA SU, e-mail
auguston@lumii.lat.su.


                     1.6 What is on your disks

    Rigal  implementation takes one or some disks. There are both
(A and B) versions on the disks.

    File names are the following :

     README  -  text  file which contains list of supplied files,
discussion  on  compatibility  with  previous  versions  and last
minute notes.

    RIG.EXE - Rigal integrated environment, version A.

    RIG1.EXE - Rigal integrated environment, version B.

    RIGCHECK.EXE - Independent checker.

    INT.EXE - Independent interpreter.

    RIGCOMP.EXE  - Independent compiler.

    RIG_*.EXE  - some components of Rigal Integrated environment.
Do not run them. They are called from the integrated environment.
They are :

    RIG_CHE.EXE - syntax checker.

    RIG_INT.EXE - interpreter.

    RIG_CRF.EXE - cross reference utility.

    RIG_LINT.EXE - type compatibility utility.

    RIG_PNT.EXE - Rigal saved object viewer.

    ANRIG.EXE - compiler, analysis part.

    GENRIG.EXE - compiler, generation part.

    TPC.EXE - Turbo Pascal compiler.

    TURBO.TPL - compiled Turbo Pascal units.

    *.RIG - examples.

    *.TXT - descriptions, guides and manuals.

    List of examples and TXT files are given in README.


                  1.7 Configuration requirements

    Rigal  is implemented for IBM/PC XT , IBM/PC AT, IBM PS/2 and
compatible  computers. It requires no less than 512 Kbytes of RAM
memory. Operation system must be MS-DOS V.3.0 or higher.

    Environment   works  depending  on  date  and  time  of  file
creation.  You  must  see  to  it that inner computer clock works
correctly.

    Version  B  requires  hard disk, version A does not. The very
huge  Rigal  programs  require up to 3 MBytes on hard disk during
their  compilation.  If  virtual  disk driver is turned on, speed
increases and hard disk is used less frequently.


              1.8 Differences between version A and B

    Version  A  is one executable file which includes the editor,
the  checker  and the interpreter. The compiler and utilities are
not included. You can use the version A without the hard disk.

    Version  B is a system of some executable files. They are the
editor,  the  checker,  the  interpreter,  the  compiler  and the
utilities.   The   virtual  disk  driver  may  be  used  for  the
effectiveness.

     There are no differences in text editor, language syntax and
semantics.


             1.9 How to install Rigal on your computer

     Make  a  new directory in your hard disk. Take all the disks
and  copy all the files to one directory of the hard disk. If the
files  are  in  the  archive, you must extract them. File READ.ME
contains  information about it. If you want to obtain only floppy
disk version, copy RIG.EXE to the floppy disk.


                    1.10 How to start up Rigal

      You  can  call  the  Rigal  Integrated environment from any
directory, e.g.

     \RIGAL\RIG1

      Your  Rigal  source files must be in the current directory.
There  are no configuration files. Setting DOS "path" variable is
not required.

      You can give a  parameter  -  file name, e.g.

     \RIGAL\RIG1 AAA.RIG

      Entering such command you start work with file AAA.RIG. The
current  disk  and directory and extension ".RIG" are default. If
the  parameter is not specified at all, then WORK.RIG is default.
If  file  does not exist, an error message appears on the screen;
press ESC to start work with this new file.


                1.11 Editor menu and the hot keys

      There is pull down menu at the top of the editor window and
functional keys list at the bottom.

      In  the text editor you can use all the letters, digits and
special  characters,  space  bar,  arrows (up, down, left, right,
page  up, page down, home, end), switch of insert/overwrite mode,
"delete",  "backspace"  and new line insertion ("Enter" in insert
mode).

     In  menu  window  you  can  use  arrows  to walk through it,
"Enter" to choose an item, "Esc" to exit menu.

     Additional hot keys are available:

     Ctrl/Y - delete current line;

     Ctrl/B  -  mark  block  starting  from  current line; editor
requires the number of lines which will be included in the block.

     Ctrl/P - paste block at the current line;

     Ctrl/F - find by pattern starting at the current line;

     Ctrl/S  -  substitute by patterns beginning from the current
line.




     Functional keys are :

     F1 - help;

     F2 - save current file;

     F3 - load another file;

     F4 - show list of some latest loaded files and choose one of
them;

     F5 - show directory (by pattern) and choose one file;

     F6 - check program syntax;

     F7 - run the program using the interpreter;

     F8 - compile the program;

     F9 - set command line parameters;

     F10 - go to the pull down menu.

     ALT/X - exit Rigal integrated environment;

     ALT/C - enter Checker and compiler sub menu;

     ALT/F - enter File sub menu;

     ALT/R - enter Run sub menu;

     ALT/S - enter  Utility  (Services) submenu.




              1.12 How to create a simple program

     You   can   call   Rigal  integrated  environment  from  any
directory:

     \RIGAL\RIG1

     Text  editor  window appears on the screen. If message "File
WORK.RIG is not found" appears, then press "ESC" key.

     Now,  press  ALT/F.  Submenu  of file manipulations appears.
Select  "Create"  line  using  up  and  down arrows. A new window
appears.  Type file name you want to create, e.g. MY.RIG. The new
text  editor  window appears. It is empty, but on the bottom line
current file name appears: MY.RIG.

     Type  the  following  program  (  letters  must  be  in  the
uppercase) :

   -- THIS IS PROGRAM

   #START

     $A:=(. ALPHA BETA GAMMA DELTA .);

     PRINT $A;

     $B:=#TAIL($A);

     PRINT $B;
   ##



   #TAIL

     (. $E (* $R!. := $K *) .)

     / RETURN $R /

   ##


     There  are two rules in this program - #START and #TAIL. The
first rule is the main one, it consists of four statements. There
are two variables - $A and $B. The first statement assigns a list
of  four atoms to the variable $A, the third statement assigns to
$B  the  result of rule #TAIL which works on the argument $A. The
second  and  the  fourth  statements  print out the values of the
variable (to the screen by default ).

     The  second  rule #TAIL consists of the list pattern (. .) ,
the  iteration pattern (* *) and the variable patterns $E and $K.
Values  of  $K  are  appended to the list in the variable $R. The
RETURN  statement  returns the result of this rule to the calling
rule.

    Press F2 (Save) key to save the program.

    Press F6 (Check) key to check the program. Checked rule names
appear on the screen. If the program has no errors, press "Enter"
to return to the text editor window. If the program has an error,
then  the  text  editor window with an error message appears. The
cursor shows the erroneous place. Correct the error on the screen
and check the program again.

    The  checker  creates  special code in file MYPROG.RSC if the
program is correct.

    Press  F7  (Run)  to execute the program. You will see on the
screen :

      (. ALPHA BETA GAMMA DELTA

      .)

      (. BETA GAMMA DELTA

      .)

    That  is  the output. The RIGAL interpreter has executed your
program.

    If  you  are  working  with  B  version,  try one more way to
execute your program. Press F8 to compile it.

    The  list  of  the  analyzed  and  coded rules and additional
information  appears  on  the  screen.  The compiler creates file
MYPROG.EXE  and  exits  the Rigal environment. Type simply MYPROG
after  DOS  command  prompt. The results of the execution will be
the same :

      (. ALPHA BETA GAMMA DELTA

      .)

      (. BETA GAMMA DELTA

      .)

   Now you can execute other examples or write them by yourself.




            2. Additional features of the language

    Some  language  limitations,  extensions  and  special  cases
depending of the implementation are discussed.


                    2.1 Rigal lexical syntax

     Tokens in Rigal programs are the following :

     -- rule names , e.g. #ABC

     -- variable names , e.g.  $VAR

     -- RIGAL key words, e.g. FORALL, ELSIF

     -- RIGAL delimiters and special  tokens, e.g. ## ! +

     -- atoms ( RIGAL data )

     The  tokens  in  different cases (upper-case and lower-case)
are different. Type the key words in the upper-case only.

    In  the  following description the LETTERS are A..Z,a..z, the
LETTERS_&_DIGITS are A..Z,a..z.0..9,_ (underscore).

    The limitations to Rigal token syntax follow.

    RULE  NAMES  begin with # followed by LETTER and zero or more
LETTERS_&_DIGITS.

    VARIABLE  names  begin  with $ followed by LETTER and zero or
more  LETTERS_&_DIGITS. If the first letter is N or I (upper-case
only),  such  pattern  variable  matches the number or identifier
respectively.

    Key words are :

    NULL  OR AND MOD DIV NOT IF ELSIF FI FORALL IN DO OD LOOP END
BREAK OPEN SAVE LOAD CLOSE PRINT LAST ONFAIL FAIL RETURN

    Delimiters and special tokens are :

    ## / ;; (* *) ! (+ +) <* *> : , ; := ++ !. !! + - * ( ) <> =<
= >= < > :: <. .> (. .) [ ] . -> << <] @ S' V'

    Numerical  atoms in Rigal are decimal, from 0 to 2**31-1. The
numbers may be written in octal mode, followed by the letter "B".

    Non-numerical  atoms are quoted by apostrophes. An apostrophe
inside the atom must be written twice.

    If  the  non-numerical  atom  is  LETTER  and  zero  or  more
LETTERS_&_DIGITS,  and  this atom is not a RIGAL keyword, then it
is allowed to write it without apostrophes.

                  2.2 Including other files

     Use  the  %INCLUDE <FILENAME>.RIG directive to include other
files  into your program. The extension (.RIG) is necessary, disk
and directory name may be specified (otherwise they are default).
The file name is followed by spaces. Use %INCLUDE only between or
after  the  rules,  rather  than  between  the  statements or the
patterns. If the included file does not exist an error message is
produced.


                        2.3 Atom  types

    The  atoms (excluding NULL) are implemented as Pascal records
which  consist  of  the  type  of  the  atom  and  the string (or
numerical) value.

     There are the following atom  types in Rigal:

     1.  IDENTIFIER.  Such  atom value is LETTER and zero or more
LETTERS_&_DIGITS.  Such  atoms match the built-in rule #IDENT and
I-variables in the patterns. They may be used as the selectors in
the trees.

     2. NON-NUMERIC atoms which are not identifiers.

     3.  NUMBER. They match built-in rule #NUMBER and N-variables
in the patterns.

     4.  PASCAL  STRING  CONSTANT. They are created by the PASCAL
scanner and match built-in rule #TATOM.

     5.  PASCAL REAL CONSTANT. They are created by PASCAL scanner
and match built-in rule #FATOM predicate. Value is represented as
string.

    Other  atom  types (KEYWORD, SPECIAL, VARIABLE, RULENAME) are
created by the Rigal scanner and intended for internal use.

              2.4   Lazy  boolean   evaluation

    The AND and OR operations are executed in the different modes
in  the  interpreter and in the compiled program. The interpreter
supports  the  full  evaluation  of  boolean expressions, but the
compiled program evaluates the necessary arguments only.

                     2.5 Opening text files

    The statement

     OPEN internal-file-name expression

   opens text file for output.

   The  expression  must  have  a  value,  which represents valid
MS-DOS file name. You can specify the disk and directory, but the
current  disk  and current directory are default. If it is not an
atom - ERROR 11 message is issued. If the file with such internal
name  is  already open, then ERROR 16 is issued, and the new file
is not being open. Only 5 files can be open simultaneously, ERROR
13  appears if you try to open the 6-th file. ERROR 14 appears if
you  try  to  output  to the closed file. ERROR 19 appears if the
file name is not valid.

    File  name  which consists of one space symbol corresponds to
the standard output (screen).

    Examples :

      OPEN  LST  'C:\DD\ABC.TXT';

      OPEN SCREEN ' ';

      OPEN   PASCODE   #IMPLODE   ($Name '.PAS');


                        2.6 Text output

   The  <]  and << statements writes the atoms to text file. NULL
is  written  as  empty  string.  The  #TATOM atoms are written in
apostrophes  and  inner  apostrophes  are duplicated. The list is
written  as  sequence  of  the atoms in the list. The name of the
list  and  the  inner structure is not printed. The trees are not
allowed to be write: the '<*!<*TREE*>!*>' mark will appear in the
text file.


               2.7 Length of the text file line

   Default length of the line is 80 bytes.

   Before  every  atom  is  written  its length and length of the
current  line are added, and the sum is checked. If the atom does
not  fit in 80 bytes, then if insert-space mode is ON, (@ switch)
it  causes  switch  to  a  new  line, but if OFF then the atom is
written to the current line (and length of this line will be more
than the default value).

                    2.8 New  line format

   The  <<  statement  writes  EOL  byte  (Chr(13))  and  CR byte
(Chr(10)) and then writes the required atoms. If the << statement
is  executed  immediately  after OPEN, the first line in the file
will be empty.

                 2.9 LOAD and  SAVE  statements

  RIGAL   data   loading   and   saving  requires  the  following
statements:

    LOAD $Variable <EXPRESSION>;

    SAVE $Variable <EXPRESSION>;

    The  expression  value  must be atom, its value must be valid
DOS  file  name. If it is not atom, ERROR 11 appears. Limitations
and defaults for DOS file name are the same as in OPEN statement.
If file name is invalid, LOAD statement causes ERROR 18, but SAVE
causes  ERROR  15.  Screen file (' ') is not allowed. If the file
does  not  exist, LOAD statement assigns NULL to the variable. If
the  variable  value  is NULL, the SAVE statement does not create
any file.


                      2.10 PRINT statement

    The  PRINT statement writes the argument value to the special
PRINT-file,  defined  in the menu or received as the command line
parameter. The output appears on the screen by default.

    Atoms,  lists  and  trees are written in structured form with
the   indentation.  The  identifiers,  numbers  and  Pascal  REAL
CONSTANTS  are written without the apostrophes, but Pascal STRING
CONSTANTS and non-numerical atoms in apostrophes. The sequence of
the tree selectors is not fixed. The maximum nesting of levels is
15. It can be changed by #CALL_PAS(78 level).

    The trace information is written to the same file in the same
format.

                     2.11. Built-in rules

    There are predicates such as #ATOM(E), #NUMBER(E), #IDENT(E),
#LIST(E)  and  #TREE(E).  They  return  their  argument  and  end
successfully or return NULL and end unsuccessfully.

    The built-in rule #LEN(E) returns the number of characters in
the atom, the number of list elements or tree branches.

    #EXPLODE(E) returns E decomposed in separate characters.

    #IMPLODE(E1  E2  ...  EN) concatenates atoms or lists E1, E2,
..., EN in a new atom.

    #CHR(N). The rule returns an atom, which consists of just one
ASCII character with the code N ( 0 <= N <= 255).

    #ORD(A). Returns an integer, which is an internal code of the
first character of the non-numerical atom A.

    #PARM(T)  . Returns list of the parameters which was assigned
when the whole program was called for execution.

    #DEBUG(E).  If E equals the atom 'RULES' then debugging trace
is  turned  ON  , if NORULES, it is turned OFF. List of debugging
trace messages is given in Appendix C.

   #CALL_PAS(N ...) - special Pascal subroutines.

    2.12 Passing parameters to the program

    If   the   RIGAL   program  is  run  under  Rigal  Integrated
Environment,  you can pass the string of parameters through menu.
If  it  is executed independently, you can pass the parameters in
the command line.

    The   string  of  parameters  is  a  sequence  of  characters
separated  by  one or more spaces. They are passed to the program
by #PARM rule . You can call it from any place in program, and in
all the cases it returns the list of parameters.

    If the parameters are absent, NULL is returned.

    If  the parameters are present, then the string of parameters
is parsed to identifiers, non-numerical atoms and numbers.             

             3. Features of the Integrated Environment

     Rigal   Program   Development   System  consists  of  Rigal
integrated  environment  and  several  additional  tools. You can
start  these  tools  from the DOS prompt. Some of these tools are
parts  of the integrated environment. This chapter covers all the
features  of  Rigal  Program Development System including all the
features of the integrated environment and the additional tools. 

                          3.1 Text editor

   You can use the text editor to enter and modify Rigal programs
and  other  text  files.  You  can also use any text editor which
operates with ASCII files. 

   You  can  start other components of the integrated environment
from  text  editor  window only. You must press corresponding hot
key  or select corresponding menu command. Hot key list is at the
bottom  of  the  screen  (see 3.1.2) , the menu bar is at the top
(see 3.1.1). 

   The  text  of  current (active) file is in the edit window. At
every  moment  the text editor processes only one file, this file
is  called  "current"  file. You can see its full name and cursor
position (row and column number) at the bottom of the screen. The
current  editor  mode  is  also  shown:  INS means "insert" mode,
spaces correspond to "overwrite" mode. 

   Pay  attention to the version number at the upper right corner
of the screen. 

                         3.1.1 Menu bar

   You can see following six menu names in the top of the screen:
Exit,   Files,   Edit,  Check/Compile,  Run  and  Special.  Press
ALT+(X,F,E,C,R,S) respectively to enter the menu. 

   Another  way  to  enter  the  menu  is to press F10 key and to
choose the menu you need by "left" and "right" arrows. 

   Exit  (Alt-X) exits the integrated environment. If the current
file  was changed but was not saved, you get warning. If you want
to  save  the  file  -  press "Y", if you don't want to save it -
press  "N", if you cancel exit the integrated environment - press
"ESC" key. 
   Files menu (Alt-F) manages files and directories (see   3.2).
   Edit (Alt-E) returns you to the edit window.
   Run  menu  (Alt-R)  starts  the  interpreter  and controls the
parameters and debug mode (see 3.4). 
   Check/Compile  menu  (Alt-C) starts the syntax checker and the
compiler. 
   Special  menu  (Alt-S)  starts  some  service utilities. These
utilities  are  cross  reference  table  (see  3.6), saved object
print-out  in  different  modes (see 3.7), the type compatibility
checker (see 3.8) and status show (see 3.9). 

                           3.1.2 Hot keys

   Look at hot key list in the bottom of the screen :
   F1  -  Show  the  help  screen containing the hot key list and
copyright information. 
   F2 - Save the current file to the disk (see 3.2).
   F3 - Load other file (see 3.2).
   F4 - Pick; select one of several latest loaded files (see 3.2).
   F5 - Select a file from the directory (see 3.2).
   F6 - Start the syntax checker (see 3.3).
   F7 - Start the interpreter (see 3.4).
   F8 - Start the compiler (see 3.5).
   F9 - Set up the parameters (see 3.4.1).
   F10 - go to the menu bar.

                          3.1.3 Editor keys

    You   can  use  all  the  keys  -  letters,  digits,  special
characters,  spaces. Use the arrows (up, down, left, right, pgdn,
pgup, home, end) to change the cursor position. 

    Key INS turns on/off the insert mode. The mode is set to "on"
when  you  begin.  If  the  insert mode is on, a new character is
inserted before the cursor position. If the insert mode is off, a
character will be written at the current cursor position. 

    Key  DEL  deletes  the  character  in  the  current position,
BACKSPACE  deletes one character left to the current position. If
you  press  BACKSPACE  at the start of the line, the current line
will be moved and appended to the previous one. 

    Key CTRL-Y deletes the current line.

    Use  buffer to move or copy a part of your file. You can move
or  copy  only  some  lines, rather than parts of the line. Press
CTRL-B  and enter number of lines to move them to the buffer. You
can see scale of the line relative numbers at the first column of
the window. These lines (starting from the current one) disappear
from  the  current  file and they are placed in the buffer. Press
CTRL-P  to  insert  an exact copy of the lines from the buffer to
the current file before the current line. Use CTRL-P twice if you
want to insert one more copy of the buffer. 

   Press  CTRL-F to search for text in the current file. Type the
text  you  want  to  search in the input box and press ENTER. The
cursor  will  be  placed to the position where text is found. The
search direction and scope is forward from the current position. 

   Press  CTRL-S  to substitute some text. Type the text you want
to  search  for  in  the first input box and the text you want to
replace  it  with  in the second input box. All the substrings in
the  file  equal  to the search text will be replaced. The search
direction and scope is forward from the current position. 

   The editor operates with text files only. You cannot enter any
special  character  from the keyboard, but if such characters are
in file, they will be seen. 

   The  width  of  the editor window is 77 characters, but moving
the  cursor to the right you can access the 128-th character. The
characters  to  the  right (129-th and so forth) are ignored when
you  load your file from the disk. If there are characters to the
right  from  77-th character then a rectangle-like symbol appears
in the last column of the screen. 

   The  maximum  size  of  the  file  depends  on the size of RAM
available.  Every line of the file occupies up to 150 bytes. When
you exit the editor this memory is disposed. 

                      3.2 File manipulations

    These  options  are  available  through "Files" menu. Some of
them are available through the hot keys too. 

    In  all  the  options  described  later,  file  name  may  be
specified  with  drive  and directory name. The current drive and
directory are default, extension ".RIG" is default. 

    Load  (F3) - loads new file from the disk. Type file name you
want  in the input box. Press ESC to cancel the operation. If the
file  does  not  exist,  you get an error. If the file exist, but
previous  (current)  file  was changed and was not saved, you get
question  about  the  problem. Press ESC to cancel the operation,
"Y" to save the current file, "N" not to save. 

    Save(F2) saves the current file to the disk.

    Pick(F4)  - loads one of the latest used files. Select one of
(up  to) eight latest loaded files. Choose "--load--" line if you
need different file. 
    Rules  of  load  operation  are  described above. The list of
eight  latest used files is hold in file RIGAL.PCK in the current
directory.  You  can erase this file, but the editor will restore
it every time when you exit the editor. 

   Dir  (F5) - loads file from the directory list. Type in a file
name  with  wildcards, which filters the file list of the current
directory  to  match  your specifications. The default file name,
"*.*"  displays all files in the current directory. File name "*"
displays   all   files  with  extension  ".RIG"  in  the  current
directory.  File  names appear in the alphabetical order followed
by  size  and creation date and time. Select file you need in the
menu.  You  can go to the next page of the list of files pressing
ENTER on the upper row of the menu. 

    WRITE  TO  -  allows  to save the current file with different
name.  The  current file name does not change. New file name must
be valid, otherwise you get an error message. Press ESC to cancel
the operation. 

    CREATE  - allows to create new empty file. New file name must
be  valid,  otherwise  you  get an error. Press ESC to cancel the
operation. 

     OS  SHELL  -  temporal  exit to the DOS command interpreter.
Press  "EXIT"  to  return  to  the  integrated  environment. This
operation is available in "B" version only. 

      QUIT  - exit the integrated environment (same as ALT-X). If
the  current  file  was  changed and was not saved, then question
appears.  Press  ESC  to  cancel  the  operation, "Y" to save the
current file, "N" not to save. 

                        3.3 Syntax checker

     To  start  the  syntax analyzer press F6 key or choose Check
command  in  Check/Compile menu. You can use command line version
too. The syntax checker analyses the current file (and previously
saves it to the disk). File extension must be ".RIG". 
     The  syntax  analyzer  checks  if  the given program matches
Rigal  language syntax definition. If other files are included by
%INCLUDE  directive,  they  also are checked. You cannot check an
included file separately, because the first rule in the file must
be "main program" and its syntax differs from other rules. 
     During  the  operation  rule names and numbers appear on the
screen. 
     The  syntax analysis continues until the first error occurs.
If  an  error  is  found, the edit window appears with the source
file  where  an error is found. Cursor is placed to the erroneous
place.  ( NOTE: For implementation technical reasons if there are
an  erroneous  variable,  the  cursor is placed to the next token
after it). 
     The  error  message  appears at the bottom of the screen. It
will  clear  automatically.  Every  message has a number, list of
messages is given in Appendix A. 
      You  can make the correction, switch the editor to the main
file of the program (if necessary) and check the program again. 
      If there are no errors in the program, intermediate code is
produced  and  it  is  saved  to  the disk in file with extension
".RSC". Message "..saving code..." appears. The intermediate code
is necessary for the interpreter. 
     You  can  start the checker RIGCHECK.EXE in the command line
mode.  Source  program  name (without extension) is the first and
the  only  parameter.  A message appears on the screen and can be
redirected  by the DOS redirection symbol (">") if necessary. The
message  contains  the  error message text, the file name and the
line  number  in  the  parentheses.  The  column is marked by "^"
character. 

                        3.4 The interpreter

      The  interpreter  runs  the  program using the intermediate
code created by the syntax checker. 
      You   can   start   the  interpreter  from  the  integrated
environment  (see  3.4.1) or from the DOS prompt (see 3.4.2). The
parameters  and  the  debug  mode  passing  is different in these
cases. Common items are described in 3.4.3. 

       3.4.1 The interpreter in the integrated environment.

   To start the interpreter press F7 key or choose Run command in
Run menu. The interpreter runs the current program, i.e. the main
source  file  of  the  program  must  be  in the edit window. The
extension  of  the  file  must  be  ".RIG", it must be previously
checked  and  the  source  must  not  be updated after the check.
Otherwise you get an error message. 
    When  the  interpretation  is terminated, press ENTER to exit
the interpreter and return to the editor window. 
    The  operation  of  the  interpreter  can  be  terminated  by
CTRL-BREAK  or by DOS errors. In version "A" the operation of the
integrated  environment  terminates,  but in version "B" only the
interpretation terminates and the editor window appears. 

    Set  up  the parameters using F9 key or Parameters command in
Run  menu.  Type  the parameters in the input box. The parameters
must  be  separated  by  one or more spaces, before the first and
after the last parameter spaces are allowed too. Press ENTER when
parameters  are  entered. Press ESC to set up an empty parameters
string.  Once  entered  the  parameters retain until you exit the
integrated   environment.   The  parameters  are  passed  to  the
interpreter  and  the  program can receive them via built-in rule
#PARM. 

     Set   up   the   debugging  mode  and  PRINT-file  name  via
corresponding  commands  in Run menu. One of three possible modes
appears  in  the  Print/Debug  line  of  the menu. Press ENTER to
switch  the  mode.  Default  mode is when PRINT is turned on, the
debugging  mode is turned off. The second mode is when both PRINT
and  debugger  are  turned off. The third mode is when both PRINT
and  the  debugger  are turned on. The PRINT-file name appears in
the  fourth  line of the menu. The PRINT statements write to this
file  and  debugger  messages  are  written  to this file too. By
default  the PRINT-file is assigned to the screen. If you want to
assign  PRINT-file to the disk, press ENTER and type file name in
the  input  box. Press ENTER when file name is entered. Press ESC
or  leave  the line empty if you want to assign the PRINT file to
the  screen.  The  debugging  and PRINT mode and file name retain
until you exit the integrated environment. 

          3.4.2 The interpreter in the command line mode.

      The command line version of the interpreter is INT.EXE. You
can  start  it  from  any  directory,  and  you  can  supply  the
intermediate code for the interpreter form any directory. 
      If  you  start  the command line version of the interpreter
without the parameters, information about the parameters appears. 
      The  first parameter specifies the name of the intermediate
code.  It  is  file  with  extension  ".RSC".  Do not specify the
extension here. If the code does not exist you get an error. 
      The  second  parameter  specifies  the  PRINT file name and
debugging  mode.  It is necessary to specify PRINT file name. Use
letter  "s"  to  assign  PRINT  file  to the screen. Use standard
fictive  file  name  "NUL"  to turn the PRINT statements off. Add
symbol  "+"  immediately after the PRINT file name to turn on the
debug mode. 

       The   program  parameters  are  placed  after  the  second
parameter.  The  parameters  must  be  separated  by  one or more
spaces.  The  parameters  are  passed  to the interpreter and the
Rigal program receives them via built-in #PARM rule (see 2.12). 

     Example:
     If you enter command line
      \RIGAL\INT  \USER\CC s+ AAA 11
     The  program  \USER\CC.RIG  will  start (if its intermediate
code  \USER\CC.RSC  exist).  PRINT  statements  will write to the
screen, debugger is turned on. Statement $X:=#PARM(T) will assign
(.AAA 11.) to the variable $X. 

   The   operation  of  the  interpreter  can  be  terminated  by
CTRL-BREAK or by DOS errors. 

            3.4.3 Program execution by the interpreter

    The  interpreter  always writes standard messages ("Beginning
of  execution" and "End of execution"). If virtual memory manager
uses the physical disk, paging statistics is also reported. 
    The   interpreter   loads  the  intermediate  code  and  then
traverses  the  code  and  interprets the encoded operations. The
interpreter  reports  the  debug  information  (if  debug mode is
turned   on)  and  the  run-time  errors.  Run-time  error  means
incorrect output operations (see 2.5, 2.9) or wrong operand types
in  some  operations.  In  most  cases  the  result  of erroneous
operation  is  NULL,  the  erroneous  statement  has  no  effect.
Run-time  error  messages  are  written  to the screen and to the
PRINT-file.  If  the  PRINT-file  is assigned to the screen, then
every  run-time  error  message  will  appear  twice. The message
consist  of  the number and text, list of error messages is given
in the Appendix B. 

                           3.5 Compiler

    To  start the compiler press F8 key or choose Compile command
in Check/Compile menu. You can use the command line version too. 
   The  command  line version of the compiler is RIGCOMP.BAT. Two
parameters  are  necessary for the compilation. First paramter is
source  file  name without extension. The second paramter is full
path of the directory of the integrated environment. 

   EXAMPLE:
   F:\RIGAL\RIGCOMP C:\SOURCE\ABC F:\RIGAL
   This program compiles ABC.RIG to ABC.EXE.

   The  compiler operates with the current program, i.e. the main
source  file  of the program must be on the screen. The extension
of  the  file must be ".RIG". At the beginning of the compilation
the  syntax  of  the  program  text is analyzed. The syntax error
messages  are  reported  exactly  like in the syntax checker (see
3.3).  The  intermediate  code of the program is not produced. If
there  was  no  errors,  command file XCR.BAT and additional file
RIGCOMP.TMP  are produced. The command file starts automatically.
During  the  operation  the  command  file  XCR.BAT  creates some
intermediate files (their names start with XCR) and compiles them
to  the  executable file with the same name as source Rigal file,
but  with  extension  ".EXE". See start of the executable file in
3.5.1 and execution - in 3.5.2. 

                     3.5.1 Compilation phases

       The  compiler operates with whole program which consist of
several  files  included  by  "%INCLUDE" directive. The separated
compilation  of  files is not supported. There are four phases of
the  compilation - syntax check, syntax analysis, code generation
and code compilation. 

       The syntax check phase executes searches for syntax errors
and produced command file XCR.BAT and additional list of included
files  RIGCOMP.TMP.  Other phases are called from XCR.BAT command
file.  Here  is  sample  of  generated  file  XCR.BAT for program
C:\SOURCE\A.RIG 

 @echo off
 call f:\rigal\cmplbeg.bat f:\rigal\
 f:\rigal\anrig.exe NUL
 f:\rigal\genrig.exe NUL
 if exist xcrg.exe del xcrg.exe
 if exist C:\SOURCE\A.exe del C:\SOURCE\A.exe
 del *.rc2
 f:\rigal\tpc.exe xcrg /m/l/Tf:\rigal\
 copy xcrg.exe C:\SOURCE\A.exe
 call f:\rigal\cmplend.bat C:\SOURCE\A
 The  command file CMPLBEG.BAT copies two files ("USEPAS.PAS" and
"SCAN.PAS")  from  the  integrated  environment  directory to the
current directory (if they do not exist already). 

 Program  ANRIG.EXE reads list of files RIGCOMP.TMP and reads the
source  Rigal  files.  These  files are analyzed and their syntax
code  is  saved to some intermediate files with extensions ".RC2"
and ".RC4". 

 Program  GENRIG.EXE  reads  list  of files RIGCOMP.TMP and reads
syntax codes. It generates some Pascal files with names XCR*.PAS. 
  You  can  MODIFY  this  line  if  you  want  to  turn off speed
optimization and eliminate the code size. In this case you should
write parameter "N": 
    f:\rigal\genrig.exe NUL N
  This  phase generates files XCRG_0.PAS, XCRG_N.PAS, XCRG_C.PAS,
XCRG.PAS  and  some  others, depending of the number of the files
included. 

   Old  executable  files  are erased from the current directory.
The intermediate files are also erased. 

   Program  TPC.EXE is Turbo Pascal Compiler. It compiles all the
intermediate  Pascal  files  into  the  file XCRG.EXE. The result
files  are  XCRG_0.TPU, XCRG_N.TPU, XCRG_C.TPU, XCRG.EXE and some
others,  depending of the number of the files included. The Turbo
Pascal  Compiler uses run-time library routines collected in file
TURBO.TPL  in  the  directory of the integrated environment. File
TURBO.TPL  is  collection  of archived Turbo Pascal Units and its
compatibility depends of Turbo Pascal version used. 
    You  can  MODIFY this line if you want to use some additional
Turbo  Pascal  options.  Currently  the  following parameters and
switches are supplied : 

     /T means directory where TURBO.TPL is in;
     /M means compilation of all the necessary (new) files only;
     /L  means  that  link  buffer is placed in the current disk,
rather than in memory. 

    Program  XCRG.EXE  is  renamed to file with name equal to the
source  program  name  and  extension  ".EXE".  At the end of the
compilation  all  the  intermediate  files  are  erased  from the
current directory. 
    The retained files are
    XCR.BAT  - you can start it once again
    RIGCOMP.TMP - is necessary for some phases of the compiler
    SCAN.PAS - Lexical analyzer, you can modify it.
    USEPAS.PAS  -  Rigal-Pascal interface programs you can modify
it. 
    You   can   add   some  corresponding  DEL  commands  in  the
CMPLEND.BAT file if you want to delete these files too. 

             3.5.2 How to start up a compiled program

  You can copy an executable file to any directory, you can start
it  from  any  directory  and  it can read and write files to any
directory. 

    The   first  parameter  should  be  PRINT-file  name.  It  is
necessary  to  specify  PRINT file name. Use letter "s" to assign
PRINT-file to the screen. Use standard fictive file name "NUL" to
turn the PRINT statements off. 
    You  can  specify  virtual  disk  drive  name after the slash
symbol  ("/").  It is recommended for huge programs or processing
huge data. 

    The  program parameters are placed after the first parameter.
The  parameters  must  be  separated  by  one or more spaces. The
parameters  are  passed  to the interpreter and the Rigal program
receives them via built-in #PARM rule (see 2.12). 

     Example:
     If you enter command line
      \USER\CC s/E AAA 11
     The  program  \USER\CC.RIG will start (if it was compiles to
\USER\CC.EXE).  PRINT  statements will write to the screen. Drive
"E"  must  be  specified as the virtual disk drive. The statement
$X:=#PARM(T) will assign (. AAA 11 .) to variable $X. 

              3.5.3 Execution of the compiled program

  If the parameters was not specified, help information about the
parameters  is  reported. At the end of the execution the program
reports  virtual  memory  statistic information (if physical disk
was in use during the execution). The operation can be terminated
by  CTRL-BREAK  or  by DOS errors. The debug information is never
reported  and  #DEBUG built-in rule has no any effect in compiled
program.  Boolean  expression  evaluation order sometimes differs
from one in the interpreter (see 2.4). 

  Run-time  error means incorrect output operation (see 2.5, 2.9)
or  wrong  operand  types  in  some operations. In most cases the
result  of an erroneous operation is NULL, an erroneous statement
has  no  effect.  The  run-time error messages are written to the
PRINT-file only. The message consist of the number and text; list
of error messages is given in the Appendix B. 

                     3.6 Cross reference table

    You   should   construct   a   cross   reference   table  for
investigating  and  debugging large programs. It helps you to see
connections between rules and variables. Following information is
supplied for every rule in your program: 
    - number and rule name,
    - list of rules calling this one,
    - list of rules called by this one,
    - list of the variables of the rule,
    - list of global variables and list of rules which use them.
   To   construct   the   Cross-reference   table  choose  "Cross
Reference"  in "Special" menu. The table is built for the current
program together with all the included files. The result file has
the  same  file  name  as  the  source  program, but extension is
".CRF". 

                   3.7 Show saved Rigal object

   If  you  saved a Rigal object to the disk it is useful to look
at the contents and the structure of the object. 

   Menu "Special" allows you to choose one of four modes:
   -  to  the screen, in pseudo graphical mode; this mode is also
implemented in command line version. 
   - to text file, in pseudo graphical mode
   - to the screen, in PRINT mode
   - to text file, in PRINT mode.
   After you select the mode in "Special" menu you should specify
file  name  (with  extension)  in  the input box. The results are
undefined the file has wrong format. 

    If  you  choose  text  file  modes,  the  result file name is
RIGSHOW.LST and this file appears in the edit window. 
    The  command  line version is program RPNT.BAT. The parameter
list is similar to the integrated evironment version. 

    You  can  also  request a component of the object rather than
whole  object.  A component is branch of tree or element of list.
You  should  specify  additional  parameters after the file name.
These   parameters   must   be  separated  by  spaces.  Following
parameters are allowed: 
    IDENTIFIER  is  accepted  as a branch label of Rigal tree and
specify  that you need the corresponding branch rather than whole
tree. 

    NUMBER  is  accepted  as index of Rigal list and specify that
you need the corresponding list element rather than whole list. 

    ?  - specifies that the component should not be printed, only
header information is reported. "?" can be only last parameter of
the parameter list. Only screen mode is supported for "?". 

    EXAMPLE
 You have an object saved in file A.KKK :
   <. NN :(. FF GG <. TT : YY , LL : PP .> JJ .), OO :II .>
 and you type in the input box
   A.KKK NN 3 LL
 as the result you will see only single atom PP.

 If you have specified parameters
    A.KKK NN 3 ?
 the following will be reported:

   tree without name TT : ID-ATOM
   LL : ID-ATOM

  The following messages can be reported:
    No such file - specified file does not exist
    Use "?" only if output to screen - reports with "?" parameter
cannot be written to the file. 
    object  is  not  list  -  number was specified for the object
which is not list. 
    object's  length-only  NNN - specified number is greater than
list length. 
    object  is not tree - identifier (branch label) was specified
for the object which is not tree. 
    object  has no such selector - identifier (branch label) does
not exist in the tree. 
    wrong  element  in parameters - a parameter is not identifier
or number. 

    In  the  report  about  header information following messages
appear: 
   For list and trees:
   NULL;  tree;  tree  without  name; tree with name; list ; list
without name; list with name; list length = NNN; list is XXX. 
   For atoms:
    F-ATOM #FATOM
    NUMBER-ATOM #NUMBER
    ID-ATOM #IDATOM
    ATOM #ATOM
    RULE-DESK  VAR-DESK  KEYW-DESK  -  Atoms constructed by RIGAL
scanner. 


                  3.8 Type compatibility checker

   There  is no type and variable declarations in Rigal language.
Nevertheless the values of different types can be assigned to the
variables.  There  are following data types: lists, trees, atoms,
numbers   and  other  data.  Using  incompatible  types  in  some
operations is evidence of error in many cases. For example, using
not-lists   in   "!!"   operation,   trees   in  "<<"-statements,
non-numeric data in the argument of the built-in rule #CHR. 
    Type  compatibility  checker (Rigal Lint) in many cases allow
to  prevent such errors. Values of different type can be assigned
to  one  variable  in different statements or pattern elements of
the  rule.  Nevertheless  it  is  place  of  possible error. Type
compatibility   checker   issues   warnings,  rather  than  error
messages.  These  warnings  should help the programmer to be more
disciplined  in  programming.  You can call "Rigal Lint" via menu
"Special".  The  current  program is analyzed (with "%INCLUDE"-ed
files).  The  messages  appear  in file with the same name as the
source program, but with extension ".LNT". 

             3.9 Status of the integrated environment

    You  can see the current status of the integrated environment
via  menu  "Special".  The status items retain unchanged when the
integrated  environment components are called. These items can be
changed via corresponding windows only 4. Lexical analyser 

     Some   built-in  utilities  for  the  lexical  analysis  are
described here. 




                   4     The new lexical analyzer
                   ------------------------------

     -  supports  Pascal,  C  and Modula-2 lexical grammar rather
than Pascal grammar only; 

     - produces named trees and lists rather than lists only;

     -  takes  input from Rigal atom, from disk file and from RAM
memory rather than from disk file only; 

     - produces error message list rather than fixed format error
files; 

     - supports different coordinate computation modes;

     -  source  Pascal  code is open to the user, and can be easy
modified. 


              4.1 The simplest lexical utility


     The lexical analysis utilities input unstructured data, e.g.
strings  of  text,  files  or data from memory and output list of
tokens  or  other  structures.  You can call them using #CALL_PAS
built-in rule. 

     The simplest utility requires a file name and it returns the
list of tokens. 

     If you write
                   $A:=#CALL_PAS(35   'A.PAS');  and  file  A.PAS
contains 
                         ABC+752 'TEXT' then $A will contain list
of 4 atoms : 
                    (. ABC '+' 752 'TEXT' .)

      The   coordinates  of  these  atoms  are  1,  4,  5  and  9
respectively.  Use  built-in  rule  #CALL_PAS(4  ..)  to  get the
coordinates. 

     Following questions are discussed here:

     How to read from text file ?
     How to analyze the atoms like 'ABC+D' ?
     How to get data from random access memory ?
     How to set options for the analyzer ?
     How to change lexical grammar ?
     How to control computation of the coordinates ?
     How to get tree and list structures ?
     How to get error messages ?


                     4.2 Reading from file


 SYNTAX:   $A:=#CALL_PAS (35 filename options)
          or
          $A:=#CALL_PAS (35 filename)
 FUNCTION: Reads tokens from disk file

 REMARKS:  Rigal tries to find given file name and read from this
file. If file is absent, NULL is returned. File is set of zero or
more   lines,   separated  by  the  newline  and  carriage-return
characters.  Each  line  is  set  of zero or more characters. The
newline  and  carriage-return  character aren't included into the
line. Lines longer than 127 characters are truncated. The lexical
grammar and the coordinates depend of options given. 


                  4.3 Reading from list of atoms


 SYNTAX:   $A:=#CALL_PAS (36 list_of_atoms options)
          or
          $A:=#CALL_PAS (36 list_of_atoms)
 FUNCTION: Forms tokens from list of atoms
 REMARKS:  Rigal  reads  data from given list. It should be Rigal
expression;  its value should be list of the non-numerical atoms.
This  list is interpreted as set of zero or more lines, each line
is  set of characters. Numeric atoms, lists and trees are ignored
(they  are  interpreted  as  empty  lines).  Lexical  grammar and
coordinates depend of options given. 
 EXAMPLE:  #CALL_PAS(36 (. ' ABC+D' (. TO IGNORE .) 'EF' .))
 returns value
                    (. 'ABC' '+' 'D' 'EF' .)


               4.4 Reading from random access memory


 SYNTAX:   $A:=#CALL_PAS (37 segment offset options)
          or
          $A:=#CALL_PAS (37 segment offset)
 FUNCTION: Reads tokens from memory

     REMARKS:  Rigal  tries  to  read data from the random access
memory  address.  The  segment  and the offset should be numbers.
This   utility   is   used  when  Rigal  program  (or  the  Rigal
interpreter) is called from resident non-Rigal user's program. 

     Symbol  Chr(13) (newline character) should be placed in byte
corresponding   to   given  memory  address.  Otherwise  NULL  is
returned. This guarantees that we read from correct place. 

     Rigal  reads  the  bytes  forward, one by one, until Chr(13)
Chr(26) Chr(13) is encountered. 

     Data  should be separated to parts. Symbol Chr(13) should be
used  as  delimiter.  Every part is interpreted as one line, each
line  is  set of characters. The newline character isn't included
into the line. 

     Lexical  grammar  and  coordinates  depend of options given.
EXAMPLE: 

     A resident program:

 Program E;                                                      
 {$M $4000,0,0 } uses Dos;                                       
 const NL=Chr(13); EF=Chr(26);                                   
 var                                                             
   datas:string;                                                 
   CmdLine,s1,s2: string;j:integer;                              
 begin                                                           
   datas:='A B C ' + NL + ' X D ' + NL+EF+NL;                    
   write('Source data=');                                        
   for j:=1 to length(datas) do write(' ',ord(datas[j]));        
   writeln;                                                      
   datas[0]:=NL; { mark about start of data }                    
   Str(Seg(datas),s1);                                           
   Str(Ofs(datas),s2);                                           
   CmdLine:='RIGPROG '+s1+' '+s2;                                
   WriteLn('Exec ', CmdLine);                                    
   SwapVectors;                                                  
   Exec(GETENV('COMSPEC'),'/C '+ CmdLine);                       
   SwapVectors;                                                  
   WriteLn('...back from Exec');                                 
   if DosError <> 0 then WriteLn('Dos error #', DosError)        
   else                                                          
     WriteLn('Exit code = ',DosExitCode);                        
 end.                                                            


     Program RIGPROG.RIG :

 #W                               
  OPEN S ' ';                     
  $B:=#PARM(T);                   
  $A:=#CALL_PAS(37 $B[1] $B[2] ); 
  PRINT $A=(. A B C X D .);       
 ##                               

     This Rigal program should print out character T ;


                          4.5 Options


     Options value should be non-numeric string containing option
characters  and + (on) or - (off) immediately after them. Default
value  of  options is 'D-C-P+p+m-U+S+O+s-t-L-A+R+Y-B-N-'. Options
supplied  by  the  user  overwrite  default  ones. Note that some
options  require  other  ones, some of them are incompatible. All
such cases are noted below. 


         4.6 Common components of the lexical grammars


     Spaces.  One  or  more  spaces, tabs, newline characters are
ignored during lexical analysis. 

     Comments. They are ignored during lexical analysis.
     The  options  allow to choose some comment start and comment
end symbols. 
     If comment is not ended at the end of file, error code 12 is
produced. 

     String constants. They are converted to TATOM atoms.
     The  options  allow to choose some string constant start and
end  symbols  and conversion modes. If end of line appears within
string constant, error code 11 is produced and string constant is
truncated. 

     Numbers. They are converted to NUMBER or FATOM atoms.
     Integer  numbers  with  less than 10 digits are converted to
NUMBER  atoms.  Integer  numbers with 10 or more digits, floating
point  numbers  and  fixed  point  numbers are converted to FATOM
atoms. Following grammar rule defines all the acceptable numbers: 

     Number ::= Digits[.[Digits]][(e|E)[(+|-)][Digits]]
     Digits ::= (*Digit*)
     Digit  ::= (0|1|...|9)

     Identifiers. They are converted to IDATOM atoms.
     Following   grammar   rule   defines   all   the  acceptable
identifiers: 
     Identifier ::= Letter (Letter|Digit|_)

     The  options  allow  to  change  the  set  of letters and to
convert all the letter to the uppercase. 

     Special symbols. They are converted to ATOMs.
     These  symbols  consist  of  2  or  more  characters. Set of
special symbols should be specified by options. 

     Single characters. They are converted to ATOMs.

     NOTE:  All  the  atoms  have  length up to 80 bytes. All the
atoms longer are truncated and error code 10 is produced. 


                       4.7 Using options


     The  specific  properties  of different lexical grammars are
set by the following option groups: 

     Special symbols:
     L - Pascal-oriented symbols
     A - C-oriented symbols

     Identifier conversion:  U - convert to uppercase

     Comment modes:
      D - Ada-like comments (--...)
      P - Pascal-like  comments ( (* *) { } )
      C - C-like comments ( /* */ )

     String constants:
      p - Pascal-like ( '..' )
      m -  Modula-2-like ( '..' and ".." )

     For  Pascal  input  use  default  options.  For  C input use
'L-A+U-P-C+p-m+'  options.  For other Pascal- or C-like languages
use  Pascal  or  C  options  and  switch  some of them on(off) if
necessary. For other languages you should modify some assignments
in  source  file  SCAN.PAS  available  in  Integrated environment
directory. 

 SYNTAX:   A+ A- (default A+)
 FUNCTION: Sets Pascal-oriented special symbols and letter set
 REMARKS:  This option sets the following special symbols:
                     :=  <=  >=  **  ..  <>
                       #Digits_and_letters
                       $Digits_and_letters
                       %Digits_and_letters
                        {$Any_characters}
     Letters are A..Z,a..z,Chr(128)..Chr(255)


 SYNTAX:   D+ D- (default D-)
 FUNCTION: Sets C-oriented special symbols and letter set
 REMARKS:  This option sets the following special symbols:
          -> ++ -- >> << == += *= -= /= %= &= ^= |= !=
                       0Digits_and_letters
     Letters are A..Z,a..z,_,$,Chr(128)..Chr(255)
 NOTE:     D+A+ is not allowed


 SYNTAX:   P+ P- (default P+)
 FUNCTION: Sets Pascal-like comments
 REMARKS:  This  option  sets  comments  start  symbol { and (* ,
comment  end  symbol  } and *) . Nested comments are not allowed.
{$...} is not comment. NOTE: Requires A+. 


 SYNTAX:   C+ C- (default C-)
 FUNCTION: Sets C-like comments
 REMARKS: This option sets comments start symbol /* , comment end
symbol */ . Nested comments are not allowed. 
 NOTE:     Requires P+.


 SYNTAX:   p+ p- (default p+)
 FUNCTION: Sets Pascal-oriented string constants
 REMARKS: String constants start and end with one apostrophe (').
An apostrophe within string constant should be written twice, but
only  one  apostrophe  is  included  into  the  atom value. NOTE:
Requires P+. 


 SYNTAX:   m+ m- (default m-)
 FUNCTION: Sets C- or Modula-oriented string constants
 REMARKS:  String constants start and end with one apostrophe (')
and is converted to TATOM , or double quotes (") and is converted
to  KEYWORD.  If  \  appears within string constant, this and the
next  character  are  included  into  the atom value. atom value.
NOTE: Requires C+. 



                   4.8  Coordinate calculation


     The  lexical analyzer assigns a number (coordinate) to every
atom  produced. This number should be in 0..65535. You can access
this  number  using  built-in  rule  #CALL_PAS(4  ..).  Following
options give different modes to calculate this number. 

     NOTE:  Coordinate  function  does  not  check for coordinate
value  overflow. The function works correctly within given bounds
only. 


 SYNTAX:   R+ (default R+)
 FUNCTION: Sets coordinate mode to Line*80+Column
 REMARKS:   This   option   sets   the   coordinate  function  to
line_number*80+column_number,   where   line_number   in  1..820,
column_number in 1..127. 


 SYNTAX:   s+R- (default R+)
 FUNCTION: Sets coordinate mode to Line
 REMARKS:  This  option  sets the coordinate function to the line
number (in 1..65535). 


 SYNTAX:   t+R- (default R+)
 FUNCTION: Sets coordinate mode to token number
 REMARKS:  This  option sets the coordinate function to the token
number (in 1..65535). 


 SYNTAX:   Y+R- (default R+)
 FUNCTION: Sets coordinate mode to the byte number
 REMARKS: This option sets the coordinate function to byte number
of  the first character of token in source (in 1..65535). Newline
and  carriage-return  characters are not included in this number.
Coordinate marks (see below) and structure control characters are
included. 


 SYNTAX:   B+R- (default R+)
 FUNCTION: Sets coordinate mode to mark_value+bytes_number
 REMARKS:  This  option  sets the coordinate function to the last
coordinate  mark value plus byte number of the first character of
token starting from the mark (in 1..65535). Newline and carriage-
return  characters  are  not  included in this number. Coordinate
marks (see below) and structure control characters are included. 


 SYNTAX:   N+R- (default R+)
 FUNCTION: Sets coordinate mode to mark_value
 REMARKS:  This  option  sets the coordinate function to the last
coordinate mark value (in 1..65535). 


                      4.9  Coordinate marks


     You  can  insert a coordinate mark Chr(17) in source and any
number  immediately  after  the mark. The coordinate mark is used
for  calculation of coordinates of all the atoms produced between
this mark and next one. The coordinate marks are not converted to
atoms. 


 EXAMPLE:
        #CALL_PAS(36 #IMPLODE ( #CHR(17) 100 ' a') 'N+R-')
      returns (.A.) and the coordinate of atom A is 100.


               4.10   Structure control characters


     You  can  insert  the structure control characters in source
for  lexical  analyzer.  It  allows  to have an arbitrary complex
structure of trees and lists rather than simple list of atoms. 

     Chr(21)   - start list
     Chr(22)   - end list
     Chr(23)   - start tree
     Chr(24)   - end tree
     Chr(25)   - assign name to object

     The entire source for lexical analyzer should be accepted by
the  following  grammar.  If the source does not matches grammar,
error codes are produced. 

     Entire_source  ::= (* Item *)

     Item ::= ( start_list (* Item *) end_list |
                start_tree (* Selector Item *) end_tree |
                name_character Item1 Item2 |
                token )
     Item1 ::= Item
     Item2 ::= Item
     Selector ::= Non-numeric_token




     The corresponding Rigal structure is

     #Entire_result  (. #Object .) ##
     #Object      ( (. (* #Object *) .) !
                    <* #Selector : #Object *> !
                    #Object1 :: #Object2 !
                    #Atom ) ##
     #Object1 #Object ##
     #Object2 #Object ##

 EXAMPLE:
      #CALL_PAS(36 #IMPLODE(#CHR(21) ' A B ' #CHR(22) ' C ' ))
 returns
     (. (. A B .) C .)


                   4.11  Lexical error messages



     The following options allow to control error messages:


 SYNTAX:   S+ S- (default S+)
 FUNCTION: Send error messages to the screen
 REMARKS:  This  option  sends  the  error  code number, line and
column  number  to  the  screen.  This  option  is  intended  for
debugging purposes.


 SYNTAX:   O+ O- (default S+)
 FUNCTION: Append error messages to the list
 REMARKS:  This  option  collects  the  error code numbers in the
special list of messages. You can have this list using

                           $LIST:=#CALL_PAS(38)

     $LIST  is  Rigal list of numeric atoms. Each number is error
code  number, but the coordinate of the numeric atom is erroneous
place  coordinate.  $LIST  is  NULL if there was no errors during
last   lexical  analysis.  This  option  is  intended  for  smart
diagnostic   purposes.   Text   of  the  lexical  error  messages
(corresponding   to   the  given  message  code  number  and  the
coordinates) should be constructed by the programmer.


                4.12 Error message code numbers


     1 - unexpected end of file before end of tree
     2 - unexpected end of file within tree branch
     3 - unexpected end of file within tree
     4 - unexpected end of file before end of list
     5 - unexpected end of tree
     6 - unexpected end of list or another control character
     7 - unexpected end of file in name
     8 - unexpected end of file in named object
     9 - unexpected control character
     10 - too long atom ( more than 80 bytes )
     11 - end of string constant not found in the current line
     12 - end of file before end of comment
     13 - control character within comment
     14 - control character within string constan
      5  Scanners   and   special   subroutines
                      (#CALL_PAS)

      The scanners and special subroutines are called in the form

  #CALL_PAS ( <number>   <parameters  ...>  )

where <number> defines the option to be executed. The options are
intended  for  interface between Rigal and Pascal data types, and
they implement procedures which cannot be written in Rigal.

    Notions mentioned here are :

    -  parameters  of  #CALL_PAS  (  after number of option ) are
Rigal  objects,  and  the  value returned from this rule is Rigal
object.

    -  non-numerical  atoms  (  including  #FATOM  ,  #TATOM  and
#IDENT), their values are used as values of Pascal type STRING.

    -  numerical  atoms  (  #NUMBER  ),  their values are used as
values of Pascal type LONGINT.

    Options are  described in ascending order.

    1.  If  the first parameter is given, the option writes it on
the screen. The parameter must be non-numerical. The option waits
for  the user's answer (Pascal READLN(STRING) executes). When the
user presses ENTER key, the option returns the non-numerical atom
containing the string. Zero length string is represented by NULL.

     EXAMPLE

   LOOP
     $E:=#CALL_PAS(1 'Enter Y or N ');
     IF $E ->
        IF ($E=Y)OR($E=y)-> $REZ:=T;BREAK;FI;
        IF ($E=N)OR($E=n)-> $REZ:=NULL;BREAK;FI;
     FI;
   END;

   This program expects Y or N from the user.

    2 and 3 .
    NOT recommended to use. See Chapter 4 (Lexical analyser).
    The  first  parameter  must  be  file  name,  and the lexical
scanner  of  Pascal  is  applied to this file. The option returns
list  of  tokens  according  to Pascal lexical rules. If the file
does  not exist, NULL is returned. The messages about the lexical
errors are written to the file with extension '.LER'.

    4.  Parameter  is  any  object, except list or tree. When the
lexical  scanner  forms  the  output  list,  every  numerical and
non-numerical  atom  contains the coordinate of the corresponding
token  in  the  source file. The coordinate is in 0..65535 and it
equals  COLUMN+ROW*80.  The  option  returns  the  value  of  the
coordinate, or 0 if the object has no coordinate.


    EXAMPLE

 #MAIN
  OPEN LST 'A.LST';
  $L:=#CALL_PAS( 3 'A.PRG');
  #TEST($L)
 ##

 #TEST
  ( 'PROGRAM' !
    $E
    / LST << #CALL_PAS(4 $E) ' is coordinate of error ' /
  )
 ##

   This  program  prints the error message with the coordinate of
the first token in file A.LST.



    5.   The  parameter  is  identifier.  The  string  containing
extended  ASCII  characters  (e.g. russian) is transformed to the
canonical  form  with  standard  character set ( for INTERNAL use
only ).

    6.  Parameter  is identifier. Controls the character set (for
INTERNAL use only ).

    7. Two parameters are file names, the first is renamed to the
second  one  by  Pascal  RENAME procedure. The numerical value of
Pascal   IORESULT   system   variable  is  returned.  Zero  value
corresponds to success.

    8.  Parameter  is file name, file is deleted by Pascal DELETE
procedure. The numerical value of Pascal IORESULT system variable
is returned. Zero value corresponds to success.

    10.  Parameter  is  any object. The option puts to the screen
the DUMP of this object. It shows the S-address, physical address
and contents of its implementation (Pascal record, 40 bytes). The
option  offers  the  user  to  enter another S-address in decimal
format and then shows the next dump. The loop continues until the
user enters 0.

    12.  Parameter  is  any  object. Object is printed out to the
PRINT  file  using  pseudo  graphic  characters of extended ASCII
code.

   Tree                  List
  name::         name::
     arc1-el1           el1
     arc2-el2           el2

    13.  Parameter  is  any  object. Object is printed out to the
screen using pseudo graphic characters of extended ASCII code.

    14  and  15.  Parameter  must  be existing file name, and the
lexical  scanner  of  Rigal  is  applied to this file. The option
returns  the  list of tokens according to Rigal lexical rules. If
the  file  does  not exist, NULL is returned. Option 14 forces to
include other files marked with %INCLUDE directive.


             ACCESS TO SOME PASCAL UTILITIES

    16.  Parameter  must  be existing file name. All the lines of
the  file  are  read  and appended to the list of atoms (one atom
corresponds to one line).

    18.  No  parameters.  The  option returns one numerical atom,
result  of  Pascal  READKEY  function. If READKEY returns 0, then
secondary READKEY result added to 256 is returned by the option.
EXAMPLE

    Pressing  key  F2 returns 256+60=316 because the scan-code of
this key is (0,60).

    19.   No   parameters.  The  option  calls  Pascal  RANDOMIZE
procedure.

    20.  The parameter must be numerical. The option calls Pascal
RANDOM   function   and  returns  the  result  (numerical  atom).
Random(N) is in 0..N-1.

    21.  Parameter must be non-numerical. The option calls Pascal
VAL  procedure  which  converts  the  string  to  number.  If the
conversion  is  impossible,  -1  is  returned.  The option always
returns a numerical atom.

               SCREEN AND SOUND UTILITIES

    22.  Parameter  must  be  numerical.  The option calls Pascal
DELAY procedure; execution is suspended for N/1000 seconds.

    23.  Parameter  must  be  numerical.  The option calls Pascal
SOUND procedure ; it turns on sound with N Hz frequency.

    24. No parameters. The option calls Pascal NOSOUND procedure;
it turns sound off.

    25. Two parameters must be numerical. The option calls Pascal
GOTOXY  procedure.  It sets the cursor to the corresponding place
in the last opened window ( in the relative coordinates).

    26. Two parameters must be numerical. The option calls Pascal
WINDOW  procedure.  It  sets  the  window  to  the  corresponding
rectangle  (in the absolute coordinates ). The first parameter is
X1+Y1*80, the second X2+Y2*80.

    27.  Parameter  must  be  numerical. The option sets value of
Pascal  system  variable  TEXTATTR.  Value is equal to Background
color  * 16 + Text color, where the background color in 0..7, the
text color in 0..15.

    28. No parameters.  The option calls Pascal CLREOL procedure.

    29. No parameters.  The option calls Pascal CLRSCR procedure.

    30. Parameter is numerical or non-numerical. The option calls
Pascal WRITE procedure and writes the value on the screen.

    31.  The  first  parameter is numerical or non-numerical. The
second  parameter  is  numerical.  The option converses the first
parameter  value  to  the  string, and spaces are added to it (or
some  last  characters are cut). The length of the string becomes
equal  to  the  second  parameter  value. The option calls Pascal
WRITE procedure and writes the string on the screen.

    32.  No  parameters.  The option returns numerical value 1 if
any  key  of  the  keyboard  is  pressed. The option calls Pascal
KEYPRESSED function.

    33.  No  parameters.  The  option returns X coordinate of the
cursor (in 1..80) . It uses Pascal WHEREX function.

    34.  No  parameters.  The  option returns Y coordinate of the
cursor (in 1..25) . It uses Pascal WHEREY function.

                      LEXICAL  ANALYSER

    35. The first parameter must be file name. The atoms are read
from  file.  The  optional  second parameter is string of scanner
options. See 4.2 for the detailed definition.

    36. The first parameter must be list of atoms(strings). These
atoms  are parsed to smaller atoms. The optional second parameter
is   string   of  scanner  options.  See  4.3  for  the  detailed
definition.

    37.  The  first  parameter  is  segment  value, the second is
offset.  The option reads the atoms from the random access memory
starting from the given address. The optional second parameter is
string of scanner options. See 4.4 for the detailed definition.

    38.  No  parameters.  The  option  returns  the list of error
message numbers. See 4.11 for the detailed definition.

                    LOW LEVEL MEMORY CONTROL

    40.  Parameter  of any type. The option returns the S-address
of the parameter (as number).

    41.  No  parameters.  The option returns the S-address of the
returned numerical atom.

    42.  No parameters. The option returns the page number of the
returned numerical atom. This number is in 0..255.

    43.  No  parameters.  If  the virtual memory manager uses the
current  (physical) disk drive as secondary disk, then the option
returns the page number of the returned numerical atom (otherwise
0 is returned).

    44. The first parameter is an atom. The second parameter (any
number  in  0..65535)  is  assigned to the coordinate of the atom
(the  first  parameter) and modified first parameter is returned.
This option is opposite to no. 4.

    45.  The  first  parameter  is  any  Rigal object. The option
clears  all  the  memory  of  the  structured objects (S-memory),
excluding  this  parameter  value, and opens the memory once more
(REOPENs).  The  option  returns  the  parameter value. All other
variable  values will be unpredictable. The option is useful only
for big iterative programs in loop in the main rule. In the Rigal
interpreter  the  option has no effect (it returns the same value
as  parameter).  Use #CALL_PAS(99 'ACON;'); immediately after the
call.

    46. The first parameter is any Rigal object. The option tests
the current environment. If the interpreter executes the program,
the  option returns the same value as the parameter, otherwise it
returns NULL.

    47.  The  first  parameter is an atom (file name). The option
returns  full  file  specification  if the file exists (otherwise
NULL). The option uses Pascal FSEARCH ( FEXPAND(X) ,'') function.

                 FAST NUMERIC AND ATOMIC TABLES

    The  terms  and the notions mentioned here are Common memory,
Elements  of  common  memory,  Numerical and Atomic tables, Table
elements,   Keys.   The  numerical  tables  with  numerical  keys
(integers)  represent  the lists of Rigal, the atomic tables with
atomic  keys (identifiers) represent the trees. Elements of table
may be any Rigal objects. Every element has its own unique key.

    The  table  utilities work much faster than traditional Rigal
operations  with  big  lists or trees. Tables are allocated in so
called  Common  memory  by  special  user  request  The user must
require  the total size of the common memory before the execution
in   the   command   line   (after   the  PRINT-file  name,  like
A.LST/M4000).  The  default  size  of  the  common  table is 1000
elements,  the  physical  limit  is 160000; every element takes 4
bytes.  Up  to  20  numerical  or atomic tables can be allocated.
Every  table has its own overflow area and is logically infinite.
The operation becomes much slower when table overflows.

    The  negative  error  codes  can  be  returned from the table
functions. Rigal outputs all the error messages only to the PRINT
file.

      The error codes follow :

    -1 : Numerical parameter required
    -2 : Parameter required
    -3 : Table is not created
    -4 : Wrong table number
    -5 : Too much tables
    -6 : No free common memory at all
    -7 : No more common memory
    -8 : Positive number required
    -9 : Warning: overflow area is used
    -10 : Rigal list required
    -11 : Rigal tree required
    -12 : Identifier required
    -13 : Table length must be positive.

    59.  Used for INTERNAL purposes only.

    60.  The  parameter  is  numerical.  The  option  ALLOCATES a
numerical  table  of  the length required. All the element values
are  empty. Every numerical table element occupies one element of
the  common  memory.  The  table  manager registers the numerical
table.  It is not possible to delete a table. The table number or
negative error code is returned.

    61.  The  parameter  is  numerical.  The  option ALLOCATES an
atomic  table  of the length required. All the element values are
empty.  Every  atomic  table  element  occupies approximately 2.2
elements  of  the  common memory. The table manager registers the
numerical  table. It is not possible to delete a table. The table
number or negative error code is returned.

     The optional second parameter is overflow area fragmentation
size; default value is 10, and the best value may be found during
experiments with different PUT/GET intensity.

    62. The parameters are :

     1 - table number
     2 - numerical or atomic key (number or identifier)
     3 - any object

     This  option  PUTs  the  object (may be NULL) into the table
corresponding  to  the  table  number and key. The option returns
NULL if the object was put or negative error code otherwise.

    63. The parameters are :

     1 - table number
     2 - numerical or atomic key ( number or identifier )

     This  option  GETS an object from the table corresponding to
table number and key. It returns an object, or NULL if the object
is absent or an error has occurred.

    64.  The parameter is a table number. The option returns CARD
of the table (the number of the not-NULL objects in the table) or
negative error code.

    65. The parameter is table number.

    The  option  UNPACKs  the  table  and  converses  it to Rigal
object.

    For NUMERIC tables it returns list of the table elements. The
Nth element value is equal to the Nth element in the list, absent
elements  are conversed to NULL. The tail of NULL elements is cut
off,  therefore  the last element of the list is not NULL. If the
table is empty, then NULL is returned.

    For  ATOMIC  tables The option returns the tree; the keys are
tree  selectors  and elements are the values under the selectors.
If  the  table  is  empty,  then  NULL  is returned. The order of
branches is arbitrary, and it is not predictable.

    66. The parameters are

    1 - table number
    2 - Rigal object.

    This  option PACKs the object into the table. For the NUMERIC
table the object must be Rigal list, for the ATOMIC table - tree.
The  table  is cleared and the Rigal object is transformed to the
table. The option returns NULL or negative error code.

   67. The parameters are

    1 - atomic table number
    2 - any number.

    This option for every number from 1 to CARD (CARD is returned
by  #CALL_PAS(64) ) returns the identifier. It is a key from this
table.  The  option  is useful for organizing loop through atomic
table.

   78. The parameter is any number.
   This option sets maximum of nested levels for PRINT
statements. The default value is 15.

   99.  Parameter is an atom which is inserted into the generated
Pascal code when the Rigal program is compiled.

   For reloading the virtual memory you can use such call:

     #CALL_PAS(99 'Closes;Opens(vdname);Acon;');

   but #CALL_PAS(45) does  it in a more  effective way.


               6   Virtual memory


      The  Rigal  programs  can  use large amount of data. At the
beginning  the  Rigal data are placed in the Random Access Memory
(in  640  KB  limit)  given  for the program. There are different
methods  of  including  other  memory  types  and place some data
there.  If the RAM memory is not enough, the disk memory is used.
When the user works in MS-DOS mode at first a virtual disk driver
is  used.  If it overflows, physical disk is used. If the virtual
disk  is  too  small  or  it  is  not  specified at all, only the
physical disk is used.
     The  RAM  memory  plus memory on the disk form Rigal virtual
memory.   The   virtual   memory   manager  controls  the  paging
algorithms.  The  memory  manager  writes the temporal files with
extension  ".TMP"  to  the  physical disk. The temporal files are
erased when the program ends.
     There  are  two  kinds  of  virtual  memory  -  A-memory and
S-memory.  A-memory  contains  texts  of  Rigal  atoms.  S-memory
contains the linked structures forming Rigal data objects (trees,
lists,  integers,  atoms).  The S-memory is divided to 8 KB pages
and  the  memory manager holds them in the RAM or in the temporal
file  on  the disk. At the beginning of the execution the virtual
memory  is  empty.  When the program works it fills the pages and
changes  them, then allocates pages on the disk, reads and writes
them  if  necessary.  If  the  program  reads  and  writes to the
physical disk, the speed decreases 4-8 times. You shold try never
use physical disk.
    Some advices about using the memory follow:
    1. Try to set free RAM from resident programs you currently
do not use.
    2. Use version B, rather than version A.
    3.  Don't load and particularly don't save to disk Rigal data
grater  than  200 KB becouse normally this data are duplicated in
the virtual memory during SAVE operation.
    4.  You  should  know that scanner results take approximately
13*N bytes, where N is number of tokens.
    When a program ends, paging manager reports information about
the  number  of  pages used, the number of page writes and reads.
This information is reported if the physical disk is used only.

    You can specify virtual disk driver in CONFIG.SYS file:
    DEVICE=RAMDRIVE.SYS 1024 512 64 /e
    Where 1024 is size of the virtual disk in KBytes. Name of the
virtual  drive  follow  name  of  the previous drive specified in
CONFIG.SYS.
    You  must  specify  this  name  in parameters of the compiled
Rigal programs. See 3.5.2 for details.



     APPENDIX A. Messages of the syntax checker

 2- SYMBOL '##' NOT FOUND AFTER THE MAIN RULE
 3- RULE NAME '#...' NOT FOUND IN THE BEGINNING OF THE RULE
 5-  SYMBOL '##' NOT FOUND AFTER THE RULE
 21-  RULE NAME '#...' NOT FOUND IN THE  BEGINNING  OF  THE   MAIN
RULE
 22-  SYMBOL '##' NOT FOUND AFTER THE MAIN RULE
 23-  MAIN RULE NAME IS BUILT-IN RULE NAME
 30-  ENDING '/' NOT FOUND AFTER LIST OF STATEMENTS
 31-  SYMBOL '.)' MATCHING '(.' WAS NOT FOUND
 37-  UNEXPECTED ELEMENT IN PATTERN
 38-  UNEXPECTED KEYWORD OR SYMBOL IN PATTERN
 40-  UNEXPECTED BRANCH  FOUND  IN  TREE  PATTERN  AFTER  VARIABLE
$A:...
 41-  VARIABLES NOT ALLOWED IN TREE PATTERN  <. $A : ...
 42-  VARIABLES NOT ALLOWED IN TREE PATTERN  <. ... [ $A : ..]
 43-  ONLY VARIABLES AND ATOMS ALLOWED  AS  BRANCH  NAME  IN  TREE
PATTERN
 44-  SYMBOL ':' NOT FOUND IN TREE PATTERN
 45-  ONLY ONE PATTERN AS BRANCH VALUE IN TREE PATTERN ALLOWED
 46-  SYMBOL ']' MATCHING ']' NOT FOUND IN TREE PATTERN
 47-  SYMBOL '.>', '*>' OR ',' MUST BE AFTER BRANCH PATTERN
 48-  PATTERN  <* ... .> NOT ALLOWED
 49-  PATTERN  <. ... *> NOT ALLOWED
 50-  A VARIABLE NOT FIND IN THE LAST BRANCH OF  <* ... *>
 51-  NO MORE THAN 5 BRANCHES IN  <* ... *> ALLOWED
 52-  SYMBOL '::' NOT ALLOWED BEFORE RULE NAME
 53-  SYMBOL '::' NOT ALLOWED BEFORE '('
 54-  MUST BE AT LEAST ONE PATTERN OR ACTION WITHIN (* *)
 55-  MUST BE AT LEAST ONE PATTERN OR ACTION WITHIN (+ +)
 56-  MUST BE AT LEAST ONE PATTERN OR ACTION WITHIN [ ]
 57-  EMPTY TREE PATTERN IS NOT ALLOWED
 58-  SYMBOL '::' IS NOT ALLOWED IN THIS POSITION
 59-  EMPTY ALTERNATIVE IN (..!..) OR EMPTY () ARE NOT ALLOWED
 61-  SYMBOL ';;' OR '##' EXPECTED
 63-  RULE NAME  #... NOT FOUND IN THE BEGINNING OF THE RULE
 64-  SYMBOL ';;' OR '##' EXPECTED
 65-  THIS RULE NAME IS BUILT-IN RULE NAME
 66-  SYMBOL ';;' OR '##' EXPECTED
 71-  WRONG DELIMITER IN (*...* .. ) PATTERN
 72-  SYMBOL ')' EXPECTED IN (*...* .. ) PATTERN
 73-  SYMBOL '*)' MATCHING '(*' NOT FOUND
 74-  WRONG DELIMITER IN (+...+ .. )
 75-  SYMBOL ')' EXPUCTED IN (+...+ .. ) PATTERN
 76-  SYMBOL '+)' MATCHING '(+' NOT FOUND
 77-  SYMBOL ']'  MATCHING '['  NOT FOUND
 81-  ONLY ONE ELEMENT MIGHT BE IN EVERY PART OF (..!..!..!..)
 82-  ONLY ONE ELEMENT MIGHT BE IN THE LAST PART OF (..!..!..!..)
 83-  UNEXPECTED SYMBOL IN PATTERN (..!..!..!..)
 84-  UNEXPECTED  '!' FOUND IN PATTERN (..!..!..!..)
 86-  SYMBOL '(' EXPECTED AFTER S' OR V'
 87-  SYMBOL ')' EXPECTED AFTER S'(... OR  V'(...
 91-  ASSIGNMENT SYMBOL ':=' EXPECTED AFTER '!!', '!.', '++' OR
'+'
 101- - INTERNAL ERROR :MAINADR<>LISTMAIN
 102- - INTERNAL ERROR : PUSH FOR TREES
 201- -INS- SYMBOL 'FI','OD', '/', '##' OR  ';' EXPECTED
 202-  SYMBOL '->' AFTER 'IF' EXPECTED
 203-  SYMBOL 'FI' AFTER 'IF...->' EXPECTED
 205-  SYMBOL '->' AFTER 'ELSIF' EXPECTED
 206-  SYMBOL 'FI' AFTER 'ELSIF...->' EXPECTED
 207-  STATEMENT EXPECTED AFTER 'ELSIF..->'
 208-  SYMBOL 'END' MATCHING 'LOOP' NO FOUND
 209-  STATEMENT EXPECTED AFTER 'IF..->';
 210-  VARIABLE NAME AFTER 'FORALL' EXPECTED
 211-  SYMBOL 'IN' AFTER 'FORALL' EXPECTED
 212-  SYMBOL 'DO' AFTER 'FORALL...IN' EXPECTED
 213-  SYMBOL 'OD' OR '' EXPECTED AFTER FORALL..DO...
 215-  SYMBOL ':=' EXPECTED AFTER THIS OBJECT
 216-  ASSIGNMENT SYMBOL ':=' EXPECTED AFTER '!!','!.','+' OR '++'
 217-  VARIABLE EXPECTED AFTER "SELECTORS"
 218-  VARIABLE EXPECTED AFTER "BRANCHES"
 220-  VARIABLE EXPECTED AFTER 'LOAD'
 221-  VARIABLE EXPECTED AFTER 'SAVE'
 222-  FILE IDENTIFIER  EXPECTED AFTER 'OPEN'
 223-  FILE IDENTIFIER  EXPECTED AFTER 'CLOSE'
 224-  WRONG BEGINNING OF THE STATEMENT
 225-  UNEXPECTED SYMBOL AFTER RULE CALL #..(..)
 301-  SYMBOL ')' EXPECTED
 302-  RULE NAME #... EXPECTED AFTER 'LAST'
 303-  VAIABLE NAME $... EXPECTED AFTER 'LAST #...'
 304-  BUILT-IN RULE NOT ALLOWED IN 'LAST'
 307-  SYMBOL '$$' ALLOWED ONLY INSIDE  S' PATTERN
 313-  SYMBOL '(' EXPECTED AFTER 'COPY'
 314-  SYMBOL ')' EXPECTED AFTER 'COPY (...'
 321-  SYMBOL ']' MATCHING '[' NOT FOUND IN EXPRESSION
 323-  UNEXPECTED SYMBOL (END OF '<<'-STATEMENT NOT FOUND)
 324-  NULL OR  A'...  NOT  ALLOWED  IN  THE  LEFT   SIDE  OF  THE
ASSIGNMENT
 325-  SYMBOL '(' EXPECTED AFTER RULE CALL IN EXPRESSION
 327-  WRONG OBJECT OR SYMBOL IN EXPRESSION
 329-  SYMBOL ':' EXPECTED IN <. ... .> CONSTRUCTOR
 330-  SYMBOL ',' OR '.>' EXPECTED IN <. ... .> CONSTRUCTOR
 331-  SYMBOL '','' IS UNEXPECTED
 405-  RULE WAS DEFINED TWO TIMES (THIS IS THE SECOND)
 406-  RULE WAS NOT DEFINED IN PROGRAM
 407-  CALL OF THE MAIN RULE NOT ALLOWED
 408-  VARIABLE $ NOT ALLOWED IN THE MAIN RULE
 409-  VARIABLE $$ NOT ALLOWED IN THE MAIN RULE
 501-  INTERNAL ERROR : 1ST PARM - NOT RULE NAME
 503-  INTERNAL ERROR : 2ND PARM - NOT VARIABLE
 504-  MORE THAN 255 VARIABLES IN RULE
 505-  MORE THAN 400 RULES IN PROGRAM
 521-  INTERNAL ERROR : no RULENAME in V-list
 522-  INTERNAL ERROR : no LISTMAIN in R-list variable list
 523-  INTERNAL ERROR : THIS RULE NOT FOUND
 524-  INTERNAL ERROR : no num in V-list 1-st parm
 525-  INTERNAL ERROR : no num in V-list 2-nd parm
 526-  RULE #### WAS NOT DEFINED IN PROGRAM
 527-  RULE #### WAS DEFINED TWO TIMES
 528-  INTERNAL ERROR : wrong type in BLTIN rule table
 699- - UNEXPECTED END OF PROGRAM

 APPENDIX B. Run time error messages
  1 - Interpreter stack size overflow (stack size = #### );
      (Usually looping in the sequence of calls)
  2 - Assignment left side is not list or tree
  3 - List index is not number
  4 - Using [..] not for list
  5 - Index value exceeds list bounds
  6 - Not list or tree after "::"
  7 - Not atomic name before "::"
  8 - NULL in left side of assignment
  9 - Not numerical value in left side of "+:=" statement
  10 - Not numerical value in right side of "+:=" statement
  11 - File specification is not atom
  12 - Too long file specification
  13 - Too much open text files
  14 - File not open for output
  15 - Unable to open file in SAVE
  16 - File was not closed before new opening
  17 - Atom length exceeds file record length
  18 - Unable to open file in LOAD
  19 - Unable to open file in OPEN
  21 - Selector after "." is not identifier
  22 - Selector in tree constructor is not identifier
  23 - Not tree before "." operation
  24 - Not tree or list as base of FORALL-IN statement
  25 - Atom length more than 80 bytes in #IMPLODE
  26 - "BRANCHES" option cannot be used for lists


 APPENDIX C. Debugging messages
  =>>>CALLS RULE #... IN STATEMENT
    1-ST ARGUMENT($):

  =>>>CALLS RULE #... IN PATTERN
    1-ST ARGUMENT($):

  >> (BRANCH NO 2)

  =>>>CALLS BUILT-IN RULE #... IN STATEMENT: SUCCESS
   RESULT:

  =>>>CALLS BUILT-IN RULE #... IN PATTERN: SUCCESS
   RESULT:

  <<<=EXITS FROM RULE #... : SUCCESS
  RESULT:

   APPENDIX D. Syntax grammar of Rigal

   Singature:
  NNNN  - nonterminal
  'TTTT' - terminal (inner quotes are duplicated)
  S1.S2  - concatenation without the delimiters
  [ S ]  - optional
  S1 ! S2  - alternative
  (* S *) - iteration 0 or more times
  (+ S +) - iteration 1 or more times
  (* S *  ) - delimiter A
  (+ S +  ) - delimiter A
  (    )  - metaparentheses

   Lexical rules:

  Letter ::= A..Z,..z
  Digit  ::= 1!2!3!4!5!6!7!8!9!0
  Number ::=  (+ digit +)
  Symbol ::= visible character
  String ::= (+ Symbol +)

                     Base rules of the grammar

  1) RIGAL_program ::= main_program  (* rule *)
  2) main_program ::= '#'.name  statements '##'
  3) rule ::= '#'.name  (* simple_rule  * ';;' ) '##'
  4) simple_rule ::=  (* ( sequence_of_patterns !
                             ( '/' statements '/' ) )  *)
                          [ 'ONFAIL' statements ]


                             Patterns

  5) sequence_of_patterns ::= (* element_of_sequence_of_patterns *)
  6) element_of_sequence_of_patterns ::=   pattern  !
                   ( '(*' sequence_of_patterns ( '*)' !
                                            ( '*' atom ')' ) !
                                            ('*' '#'.name ')' )    )!
                   ( '(+' sequence_of_patterns (  '+)' !
                                             ('+' atom ')') !
                                             ('+' '#'.name  ')')   )!
                   ( '['  sequence_of_patterns  ']' ) !
                   ( '('  sequence_of_patterns  ')' ) !
                   ( '('  (+ element_of_sequence_of_patterns  + '!') ')' )
  7) pattern ::= ( [ variable  assignment_symbol ]
                          ( atom !
                            variable !
                            '#'.name !
                            pattern_of_list !
                            pattern_of_tree !
                            'S''' '(' expression ')' !
                            'V''' '(' expression ')' !
                            ( '(' (* pattern * '!' ) ')' )
                          )
                  ) !
         ( [ '/' statements '/']  pattern  ['/' statements '/'] )
  8) variable ::= '$'.name
  9) assignment_symbol ::= [ '+' ! '++' ! '!!' ! '!.'  ] ':='
  10) atom ::= name !  number !  number.'B' !  'NULL' !
               ( ''''.    String       .'''' )
  11) name ::= letter [. (* ( letter ! digit ! '_' ) *) ]
  12) pattern_of_list ::=
        [ ( atom ! variable ) '::' ]   '(.' sequence_of_patterns '.)'
  13) pattern_of_tree ::=
          [ ( atom ! variable ) '::' ]
          (( '<.' (* element_of_pattern_of_tree * ',') '.>' ) !
           ( '<*' (* element_of_pattern_of_tree  ',' *)
                  variable ':' pattern '*>' )       )
  14) element_of_pattern_of_tree ::=
        ( atom ':' pattern )  !  ( '[' atom ':' pattern ']' )

                            Statements

  15) statements ::= (* statement * ';' )   [ ';' ]
  16) statement ::=  assignment !  condition!  input_output !
              return ! fail ! loop ! call ! break
  17) assignment ::= object  assignment_symbol  expression
  18) condition ::= 'IF' expression  '->' statements
                    (* 'ELSIF' expression '->' statements ')  'FI'
  19) input_output ::=
              ('LOAD'  variable  filename   )!
              ('SAVE'  variable  filename   )!
              ('OPEN' name  filename  )!
              ( name '<<' (* ( expression ! '@' ) *)  )!
              ( name '<]' (* ( expression ! '@' ) *)  )!
              ( 'CLOSE' name )    !   ( 'PRIN' expression )
  20) filename ::=  expression
  21) return ::= 'RETURN' expression
  22) fail ::= 'FAIL'
  23) loop ::= ( 'FORALL'
                 [ ['SELECTORS']  variable ]
                 [ 'BRANCHES' variable ]
                 'IN' expression
                     'DO' statements 'OD'   ) !
               ( 'LOOP'  statements  'END' )
  24) break ::=  'BREAK'

                     Expressions

  25) object ::=
          [ prefix ] ( variable ! '$' )   (* index ! selector *)
  26) expression ::=   atom !
              ( [ prefix ] ( variable ! '$' ! '$$' ) ) !
              constructor !
              ( un_operation expression ) !
              ( expression bin_operation expression ) !
              call !
              ( expression (+ index ! selector +) ) !
              ( '(' expression ')' )
  27) prefix ::= 'LAST' '#'.name
  28) index ::= '[' expression ']'
  29) selector ::= '.' expression
  30) constructor ::= constructor_of_list !  constructor_of_tree
  31) constructor_of_list ::= '(.' (* expression *) '.)'
  32) constructor_of_tree ::=
                    '<.' (* expression ':' expression * ',')  '.>'
  33) bin_operation ::= '!!' ! '!.' ! '++' ! '='  ! '<>' !
               'AND' ! 'OR' ! '+'  ! '-'  ! '*'  ! 'DIV'! 'MOD'!
               '>'  ! '<'  ! '>=' ! '<=' ! '::'
  34) un_operation ::= 'NOT' ! '-'
  35) call ::= '#'.name '(' (* expression *)  ')'



   APPENDIX E.      FAST REFERENCE TABLE ON  #CALL_PAS PARAMETERS

   (*********************************************************)
   (********                             ********************)
   (********     VERSION   2.28          ********************)
   (********                             ********************)
   (*********************************************************)


   ATOM_OR_NULL:=#CALL_PAS(1 ATOM) WRITE and READLN from screen
   LIST_OR_NULL:=#CALL_PAS(2 FILENAME) Pascal scanner
   LIST_OR_NULL:=#CALL_PAS(3 FILENAME) Pascal scanner
   NUM:=#CALL_PAS(4 ATOM_OR_NUM) Takes coordinate
   IDENT:=#CALL_PAS(5 IDENT) Recodes russian identifier
   IDENT_OR_NULL:=#CALL_PAS(6 IDENT) Identifier is russian ?
   NUM_IoResult:=#CALL_PAS(7 FILE1 FILE2) RENAME
   NUM_IoResult:=#CALL_PAS(8 FILE) DELETE
   #CALL_PAS(10 ANY) Prints hexadecimal dump
   #CALL_PAS(12 ANY)    Nice print to PRINT file
   #CALL_PAS(13 ANY)    Nice print to screen
   LIST_OR_NULL:=#CALL_PAS(14 FILENAME) Rigal scanner with %INCLUDE
   LIST_OR_NULL:=#CALL_PAS(15   FILENAME)   Rigal   scanner  without
   %INCLUDE
   LIST_OR_NULL:=#CALL_PAS(16 FILENAME) Reads file by lines
   NUM:=#CALL_PAS(18) READKEY (0..255, 256+0..256+255)
   #CALL_PAS(19) RANDOMIZE
   NUM:=#CALL_PAS(20 NUM) RANDOM ( NUM )
   NUM:=#CALL_PAS(21 ATOM) Numerical VAL of string. (NULL if error)
                           37L, 37l is also allowed.
   #CALL_PAS(22 NUM)         DELAY
   #CALL_PAS(23 NUM)         SOUND
   #CALL_PAS(24)             NOSOUND
   #CALL_PAS(25 X Y)         GOTOXY(X,Y)
   #CALL_PAS(26 X1+Y1*80 X2+Y2*80) WINDOW(X1,Y1,X2,Y2)
   #CALL_PAS(27 B_COL*16+TEXT_COL) TEXTATTR:=...
   #CALL_PAS(28)             CLREOL
   #CALL_PAS(29)             CLRSCR
   #CALL_PAS(30 NUM_OR_ATOM)  WRITE
   #CALL_PAS(31 NUM_OR_ATOM SIZE) WRITE(X:SIZE)
   NULL_OR_1:=#CALL_PAS(32) KEYPRESSED (yes=1)
   X:=#CALL_PAS(33) WHEREX (where cursor)
   Y:=#CALL_PAS(34)          WHEREY
   $LIST:=#CALL_PAS(35 FILE [OPTIONS]) LEXICAL ANALYSER OF FILE
   $LIST:=#CALL_PAS(36 LIST_OF_STRINGS [OPTIONS])
                             LEXICAL ANALYSER OF STRINGS
   $LIST:=#CALL_PAS(37 SEGM OFS [OPTIONS])
                             LEXICAL ANALYSER OF RAM ADDRESS
   $LIST_OF_NUM:=#CALL_PAS(38)  LEXICAL ERROR LIST
   NUM:=#CALL_PAS(40 ANY)    S-ADDRESS
   NUM:=#CALL_PAS(41)        S-ADDRESS of itself
   NUM:=#CALL_PAS(42)        Page number
   NUM:=#CALL_PAS(43) Page number on disk (or 0)
   NUM_OR_ATOM:=#CALL_PAS(44 NUM_OR_ATOM NUM) Assign new  coordinate
   to atom.
   ANY:=#CALL_PAS(45 ANY)    Reopens memory
   ANY_OR_NULL:=#CALL_PAS(46 ANY) NULL if this program is compiled
    Argument if it is run by the interpreter.
   EXPANDED_FILENAME_OR_NULL:=#CALL_PAS(47  [ FILENAME ])
    Expands file name by adding full path.
    If FILENAME is not given, CURRENT directory path is returned
    with ending '\'.
   FILENAME_OR_NULL:=#CALL_PAS(48  FILENAME)  Returns FILENAME is
   such file exists ?

   =============== WORK with tables ====================
   TABNUM:=#CALL_PAS(60 SIZE)   Allocate numerical
   TABNUM:=#CALL_PAS(61 SIZE [ FRAGMSIZE ] ) Allocate atomic
   NULL_or_ERNUM:=#CALL_PAS(62 TABNUM  KEY  ANY)    PUT
   ANY:=#CALL_PAS(63  TABNUM  KEY)      GET
   SIZE:=#CALL_PAS(64  TABNUM)          CARD
   LIST_OR_TREE:=#CALL_PAS(65  TABNUM)  UNPACK
   NULL_OR_ERNUM:=#CALL_PAS(66 TABNUM LIST_OR_TREE)  PACK
   KEY:=#CALL_PAS(67 TABNUM NUM) KEY by order
   68,69,70,71,72 - Reserved for tables
   ============== DDE of Protocol 1 =====================
   #CALL_PAS(73 APPL_NAME TOPIC_NAME) waits for the answer
     from WINDOWS DDE Client
   STRING:=#CALL_PAS(74) waits and gets WINDOWS DDE message
   #CALL_PAS(75 STRING)  sends WINDOWS DDE message

   T:=#CALL_PAS(76 T)  allocates buffers for WINDOWS DLL
    Returns NULL if unsuccess
   LIST_of_rez:=#CALL_PAS(77 (.Parm1 Parm2 ... .) ) calls a WINDOWS
    SFDLL.DLL screen management service
    The parameters can be ATOMS, NUMBERS or one-level list of atoms,
    which represents splitted string. (. 'AB'  'C' .) is the same as 'ABC'.
    LIST_of_rez is the same types of parameters. Error is reported
    in 1st or 2nd element.
    NULL is reported if there are errors in parameter list.


   #CALL_PAS(78 DEPTH) maximal depth for PRINTs

   $ATOM:=#CALL_PAS(79 TREE BRANCH_VALUE)
    Returns selector; BRANCH_VALUE must be Numeric or non-numeric atom
   $NUMBER:=#CALL_PAS(79 LIST ELEMENT_VALUE)
    Returns index. ELEMENT_VALUE must be Numeric or non-numeric atom
   If unsuccess, returns NULL.

   =============== Float processor =====================
   #CALL_PAS(80 OP ???) Float processor:
   #FATOM or NULL:=#CALL_PAS(80 S String)  -- convertion
   #FATOM:=#CALL_PAS(80 I #NUMBER) --  ---"---
   #NUMBER:=#CALL_PAS(80 T #FATOM) -- Truncation
  (.0 0.) or (.bef aft):=#CALL_PAS(80 D #FATOM) - Digit number before and after
  -- point in decimal real numbers.
   String:=#CALL_PAS(80  Z #FATOM X*100+Y) -- Formatter
     (  X digits, Y after point )
   #FATOM OR NULL:=#CALL_PAS(80  op #FATOM #FATOM) "op" is +
   - * / < > = <= >= <>
    (!) SEE MORE DETAILS IN "80.TXT"

   #CALL_PAS(81 APPL_NAME TOPIC_NAME) initializes a WINDOWS
     window of the application
   $REZ:=#CALL_PAS(82   TITLE STRING_WITH_nl  [MODE] )
     shows a WINDOWS Message box, returns button
     pressed.
     Default mode is mb_iconInformation+mb_ok.
     If MODE is 36 then "Yes" is 6, "No" is 7
     -- the same is available with R_MESSA functiuon of GRAD.DLL
   $REZ:=#CALL_PAS(83 TITLE  TEXT) shows a WINDOWS input
     box, returns modified text.
   #CALL_PAS(84 N VALUE) modifies a WINDOWS WinCrt window of
    the application BEFORE the very first output.
    N=1,2 WindowORG N=3,4 WindowSIZE N=5,6 ScreenSIZE

   TEXT:=#CALL_PAS(85 TEXT)  UPPERCASE
   TEXT:=#CALL_PAS(86 TEXT)  LOWERCASE
   TEXT:=#CALL_PAS(87 TEXT N1 [HOW_MANY])  SUBSTR(TEXT,N1,HOW_MANY)
     (default - to the end)
   NUM:=#CALL_PAS(88 TEXT1 TEXT2) POSITION OF TEXT1 IN TEXT2,
     (0 if not found)
   LIST:=#CALL_PAS(89) Returns data and time:
   (. YEAR MONTH DAY WEEKDAY HOUR MIN SEC MICROSEC .)
   #CALL_PAS(90 [Parm1])
      closes files,
      in MS-Windows- sends Message with code WM_USER+Parm1
                    (here by default and
                     when every application terminates,
                     WM_USER+105 is sent )
      Halts program with halt code Parm1.

   $LIST_OR_NULL:=#CALL_PAS(91 LIST)
     Removes (at place) last elements of the list.
     If list length is 1 or 0 then NULL is returned and argument is
     not modified.

   $ANY:=#CALL_PAS(92 ADDRESSING_LIST  ANY_STRUCTUTRE)
      ADDRSSING is list of numbers and identifier. If number, then indexing
      is applied to the 2nd argument, if identifier, then selection is
      applied.
      #CALL_PAS(92 (. A (-2) .) $S  is the same as $S.A[-2]

   SIZE:=#CALL_PAS(93)
      Returns stack size

   #CALL_PAS(99 'a Pascal statement') insert to the code

   $RET_CODE_OR_HANDLE:=#CALL_PAS(101 LIBARY_FILE)
     Loads DLL library. Currently only GRAD.DLL is valid library for
     call with this option.
     You MUST analyze the return code.
     You MUST call #CALL_PAS(103) before termination of your application
     -1 - no enough memory
     -2 - wrong parameters
     0..32 - WinExec return codes
     33 - Library handle. You MUST use it in #CALL_PAS(102 $handle ...)

   $RET_CODE_OR_RESULT:=
      #CALL_PAS(102 $handle FUNCTION_NAME (. Parm1 Parm2 ... ParmN .) )
      Calls DLL function.
      You MUST have successful call of #CALL_PAS(76) and
        #CALL_PAS(101..) before this call
      You MUST analyze the return code.
      The parameters can be ATOMS, NUMBERS or one-level list of atoms,
      which represents splitted string. (. 'AB'  'C' .) is the same as 'ABC'.
 1000   #CALL_PAS(76) was not called
 1001   1st paramter is not number
 1002   2nd paramter is not atom
 1003   3 handle is less than 32, Library was not opened for access
 1004   no memory 80 bytes
 1005   parameters are not formed in list,
       possible atom instead of list
 1006   function not found in library
        (function must be declared as FAR and EXPORT)
 1008   descriptor too small  (see P_max_size in RIF.PAS )
 1009   too many parameters   (see P_max_cnt  in RIF.PAS )
 1010   wrong atoms in list of atoms which must represent
        super long string (only  non numeric atoms allowed)
 1011   wrong element (tree) in parameters
 (. ResParm1 ResParm2 ... .)
 Result  parameters are of the same 3 types as input parameters
 SEE GRAD.TXT for description of the functions.

   #CALL_PAS(103 $handle)  Frees library. Invalidates the handle.

   $RET_CODE:=#CALL_PAS(104 EXEFILE_WITH_PARAMETERS [ MESS_NUM ] )
    Calls EXE-FILE as Windows application; Waits until the application
    returns message with code WM_USER+MESS_NUM. Default MESS_NUM=105
    RET_CODE is one of WinExec return codes.
    If you call a Rigal application from Rigal application then don't
    use this #CALL_PAS with default value.

   $DIRNAME:=#CALL_PAS(105) Home directory (where EXE or RSC file
                located)   ( with '\' symbol)

   $RET_CODE:=#CALL_PAS(106 EXEFILE_WITH_PARAMETERS [ MESS_NUM ] )
    Calls EXE-FILE as Windows application; Waits until the application
    returns message with code WM_USER+MESS_NUM. Default MESS_NUM=104
    RET_CODE is one of WinExec return codes

   $RET_CODE:=#CALL_PAS(107 COMMAND_LINE_WITH_PARAMETERS  )
    Calls BAT-FILE or any MS-DOS or Windows application;
    Windows application starts to work parallelly with the
    calling application.
    RET_CODE is one of WinExec return codes

   ATOM_OR_NUMBER_OR_NULL:=#CALL_PAS(108 ENV_VAR)
    Returns value of environment variable (possible,numeric),
    or NULL if not found.

   #CALL_PAS(109 FROM_FILE TO_FILE) Cuts all part of every
    read line after symbol ';' (including it)

   NUM:=#CALL_PAS(110 NUM1  ) Returns  SQRT(NUM1)
   NUM:=#CALL_PAS(111 NUM1 NUM2) Returns  SQRT(NUM1*NUM1+NUM2*NUM2)

   HANDLE:=#CALL_PAS(112 CODE)
    Saves S-code into memory stream.
    HANDLE is global Windows memory handle

   CODE:=#CALL_PAS(113 HANDLE)
    Loads S-code from memory stream.
    HANDLE is global Windows memory handle


   list_of_tokens:=#CALL_PAS(114 HANDLE [ SCANER_OPTIONS ] )
    Calls scaner for analyse memory stream in global memory.
    HANDLE is Windows global memory handle
    SCANER_OPTIONS are the same as in #CALL_PAS(35 ...) 

   STRING:=#CALL_PAS(116 STRING)
    String conversion for writing C string constants:
    A\B"C will be "A\\B\"C"   

   LIST_of_rez:=#CALL_PAS(117 (.Parm1 Parm2 ... .) ) calls a WINDOWS
    RFDLL.DLL screen management service
    The parameters can be ATOMS, NUMBERS or one-level list of atoms,
    which represents splitted string. (. 'AB'  'C' .) is the same as 'ABC'.
    LIST_of_rez is the same types of parameters. Error is reported
    in 1st or 2nd element.
    NULL is reported if there are errors in parameter list.

   LIST_of_rez:=#CALL_PAS(118 (.Parm1 Parm2 ... .) ) calls a WINDOWS
    RFDLL.DLL screen management service

   (. AVAIL COMPACTED .):=#CALL_PAS(119)
    size of available and size of compact memory (in Windows only)



   NULL or
   (. Shortname Size Time Attr.):=#CALL_PAS(120 [ Path [ Attr ] ] )
     First time Path must be given. Next times Path must not be
     given. Default Attr=32 (normal file). Searches files that
     match "Path" string. NULL if no files. Shortname is up to 13
     bytes long name of file.